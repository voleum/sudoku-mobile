# 2.2.5 Определение паттернов проектирования

## Статус: ✅ Завершено
**Дата начала**: 19 сентября 2025
**Дата завершения**: 19 сентября 2025
**Ответственный**: voleum

---

## Общая философия паттернов

### 🎯 Принципы выбора паттернов

**Основные критерии:**
1. **SOLID принципы** - соответствие принципам объектно-ориентированного дизайна
2. **Простота и читаемость** - избегание overengineering
3. **Тестируемость** - паттерны должны упрощать unit testing
4. **Performance** - минимальные накладные расходы для мобильной платформы
5. **React Native совместимость** - адаптация под экосистему React

**Архитектурная иерархия:**
```
Clean Architecture (Общая структура)
    ↓
Repository Pattern (Слой данных)
    ↓
Dependency Injection (Управление зависимостями)
    ↓
Конкретные паттерны по слоям
```

---

## 🏗️ Архитектурные паттерны

### 1. Clean Architecture (Чистая архитектура)

```typescript
// Общая структура слоев
┌─────────────────────────────────────────────────────────────────────┐
│                      CLEAN ARCHITECTURE                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │                   ENTITIES (Сущности)                      │    │
│  │  ┌───────────────┬─────────────┬─────────────────────────┐  │    │
│  │  │     Game      │    Cell     │      Statistics         │  │    │
│  │  │               │             │                         │  │    │
│  │  │- id           │- value      │- gamesPlayed            │  │    │
│  │  │- grid         │- isFixed    │- averageTime            │  │    │
│  │  │- difficulty   │- notes      │- bestTime               │  │    │
│  │  │- rules        │- validate() │- updateStats()          │  │    │
│  │  └───────────────┴─────────────┴─────────────────────────┘  │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                              ↑                                     │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │                  USE CASES (Варианты использования)        │    │
│  │  ┌───────────────┬─────────────┬─────────────────────────┐  │    │
│  │  │ StartNewGame  │  MakeMove   │     UseHint             │  │    │
│  │  │               │             │                         │  │    │
│  │  │- validate()   │- validate() │- findBestHint()         │  │    │
│  │  │- generate()   │- apply()    │- applyHint()            │  │    │
│  │  │- save()       │- checkWin() │- updateScore()          │  │    │
│  │  └───────────────┴─────────────┴─────────────────────────┘  │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                              ↑                                     │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │                INTERFACE ADAPTERS (Адаптеры)               │    │
│  │  ┌───────────────┬─────────────┬─────────────────────────┐  │    │
│  │  │  Controllers  │ Presenters  │     Gateways            │  │    │
│  │  │               │             │                         │  │    │
│  │  │- GameController│- GameVM     │- IGameRepository        │  │    │
│  │  │- InputHandler │- StatsVM    │- ISettingsStorage       │  │    │
│  │  │- EventHandler │- UIState    │- IAnalyticsService      │  │    │
│  │  └───────────────┴─────────────┴─────────────────────────┘  │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                              ↑                                     │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │               FRAMEWORKS & DRIVERS (Фреймворки)            │    │
│  │  ┌───────────────┬─────────────┬─────────────────────────┐  │    │
│  │  │      UI       │  Database   │      External           │  │    │
│  │  │               │             │                         │  │    │
│  │  │- React Native │- SQLite     │- Firebase               │  │    │
│  │  │- Navigation   │- AsyncStore │- Push Notifications     │  │    │
│  │  │- Animations   │- MMKV       │- Analytics              │  │    │
│  │  └───────────────┴─────────────┴─────────────────────────┘  │    │
│  └─────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────┘
```

**Реализация в TypeScript:**

```typescript
// Domain Layer - Business Entities
export class GameEntity {
  constructor(
    public readonly id: string,
    public readonly originalGrid: SudokuGrid,
    public currentGrid: SudokuGrid,
    public readonly difficulty: DifficultyLevel,
    public readonly rules: SudokuRules
  ) {}

  makeMove(row: number, col: number, value: number): MoveResult {
    // Бизнес-логика валидации хода
    if (!this.rules.isValidMove(this.currentGrid, row, col, value)) {
      return MoveResult.invalid();
    }

    this.currentGrid[row][col] = value;

    if (this.rules.isComplete(this.currentGrid)) {
      return MoveResult.gameComplete();
    }

    return MoveResult.success();
  }
}

// Use Cases Layer - Application Business Rules
export class MakeMoveUseCase {
  constructor(
    private gameRepository: IGameRepository,
    private analyticsService: IAnalyticsService
  ) {}

  async execute(request: MakeMoveRequest): Promise<MakeMoveResponse> {
    // 1. Получаем игру
    const game = await this.gameRepository.findById(request.gameId);
    if (!game) throw new GameNotFoundError();

    // 2. Применяем ход
    const result = game.makeMove(request.row, request.col, request.value);

    // 3. Сохраняем изменения
    await this.gameRepository.save(game);

    // 4. Логируем аналитику
    await this.analyticsService.trackMove(request);

    return MakeMoveResponse.from(result);
  }
}

// Interface Adapters Layer - Convert data between layers
export class GameController {
  constructor(private makeMoveUseCase: MakeMoveUseCase) {}

  async handleMove(dto: MakeMoveDTO): Promise<GameStateDTO> {
    const request = MakeMoveRequest.from(dto);
    const response = await this.makeMoveUseCase.execute(request);
    return GameStateDTO.from(response);
  }
}
```

### 2. Repository Pattern (Репозиторий)

```typescript
// Интерфейс репозитория (Domain Layer)
export interface IGameRepository {
  findById(id: string): Promise<GameEntity | null>;
  findByUser(userId: string): Promise<GameEntity[]>;
  save(game: GameEntity): Promise<void>;
  delete(id: string): Promise<void>;
  findActive(): Promise<GameEntity[]>;
}

// Реализация репозитория (Infrastructure Layer)
export class SQLiteGameRepository implements IGameRepository {
  constructor(
    private database: SQLiteDatabase,
    private mapper: GameEntityMapper
  ) {}

  async findById(id: string): Promise<GameEntity | null> {
    const query = 'SELECT * FROM games WHERE id = ?';
    const result = await this.database.executeSql(query, [id]);

    if (result[0].rows.length === 0) return null;

    const row = result[0].rows.item(0);
    return this.mapper.toDomain(row);
  }

  async save(game: GameEntity): Promise<void> {
    const data = this.mapper.toPersistence(game);

    const query = `
      INSERT OR REPLACE INTO games
      (id, difficulty, original_grid, current_grid, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?)
    `;

    await this.database.executeSql(query, [
      data.id, data.difficulty, data.originalGrid,
      data.currentGrid, data.createdAt, Date.now()
    ]);
  }

  async findActive(): Promise<GameEntity[]> {
    const query = `
      SELECT * FROM games
      WHERE status IN ('active', 'paused')
      ORDER BY last_played_at DESC
    `;

    const result = await this.database.executeSql(query);
    return this.mapper.toDomainList(result[0].rows);
  }
}

// Composition Root - регистрация зависимостей
export class DependencyContainer {
  register(): void {
    // Регистрация репозитория
    this.container.register<IGameRepository>(
      'GameRepository',
      () => new SQLiteGameRepository(
        this.container.resolve('Database'),
        this.container.resolve('GameMapper')
      )
    );
  }
}
```

### 3. Dependency Injection (Внедрение зависимостей)

```typescript
// IoC Container для управления зависимостями
export class DIContainer {
  private dependencies = new Map<string, any>();
  private singletons = new Map<string, any>();

  register<T>(
    token: string,
    factory: () => T,
    lifetime: 'singleton' | 'transient' = 'transient'
  ): void {
    this.dependencies.set(token, { factory, lifetime });
  }

  resolve<T>(token: string): T {
    const dependency = this.dependencies.get(token);
    if (!dependency) {
      throw new Error(`Dependency ${token} not registered`);
    }

    if (dependency.lifetime === 'singleton') {
      if (!this.singletons.has(token)) {
        this.singletons.set(token, dependency.factory());
      }
      return this.singletons.get(token);
    }

    return dependency.factory();
  }
}

// Регистрация зависимостей
export class ServiceRegistration {
  static register(container: DIContainer): void {
    // Infrastructure
    container.register('Database', () =>
      SQLite.openDatabase({ name: 'sudoku.db' }), 'singleton'
    );

    // Repositories
    container.register<IGameRepository>('GameRepository', () =>
      new SQLiteGameRepository(
        container.resolve('Database'),
        container.resolve('GameMapper')
      )
    );

    // Use Cases
    container.register('MakeMoveUseCase', () =>
      new MakeMoveUseCase(
        container.resolve('GameRepository'),
        container.resolve('AnalyticsService')
      )
    );

    // Mappers
    container.register('GameMapper', () => new GameEntityMapper());
  }
}

// Использование в React компонентах
export const useGameService = () => {
  return container.resolve<MakeMoveUseCase>('MakeMoveUseCase');
};
```

---

## 📝 Поведенческие паттерны

### 1. Observer Pattern (Наблюдатель)

```typescript
// Event-driven архитектура для игровых событий
export interface GameEvent {
  type: string;
  timestamp: number;
  data: any;
}

export interface IGameEventObserver {
  handle(event: GameEvent): Promise<void>;
}

export class GameEventBus {
  private observers = new Map<string, IGameEventObserver[]>();

  subscribe(eventType: string, observer: IGameEventObserver): void {
    if (!this.observers.has(eventType)) {
      this.observers.set(eventType, []);
    }
    this.observers.get(eventType)!.push(observer);
  }

  async publish(event: GameEvent): Promise<void> {
    const observers = this.observers.get(event.type) || [];

    // Параллельная обработка событий
    await Promise.all(
      observers.map(observer => observer.handle(event))
    );
  }

  unsubscribe(eventType: string, observer: IGameEventObserver): void {
    const observers = this.observers.get(eventType) || [];
    const index = observers.indexOf(observer);
    if (index > -1) {
      observers.splice(index, 1);
    }
  }
}

// Конкретные наблюдатели
export class StatisticsUpdateObserver implements IGameEventObserver {
  constructor(private statisticsService: IStatisticsService) {}

  async handle(event: GameEvent): Promise<void> {
    switch (event.type) {
      case 'GAME_COMPLETED':
        await this.statisticsService.recordGameCompletion(event.data);
        break;
      case 'MOVE_MADE':
        await this.statisticsService.recordMove(event.data);
        break;
      case 'HINT_USED':
        await this.statisticsService.recordHintUsage(event.data);
        break;
    }
  }
}

export class AchievementObserver implements IGameEventObserver {
  constructor(private achievementService: IAchievementService) {}

  async handle(event: GameEvent): Promise<void> {
    if (event.type === 'GAME_COMPLETED') {
      await this.achievementService.checkAchievements(event.data);
    }
  }
}

// Использование в Use Case
export class MakeMoveUseCase {
  constructor(
    private gameRepository: IGameRepository,
    private eventBus: GameEventBus
  ) {}

  async execute(request: MakeMoveRequest): Promise<void> {
    // Делаем ход
    const game = await this.gameRepository.findById(request.gameId);
    const result = game.makeMove(request.row, request.col, request.value);

    await this.gameRepository.save(game);

    // Публикуем событие
    await this.eventBus.publish({
      type: 'MOVE_MADE',
      timestamp: Date.now(),
      data: { gameId: game.id, move: request, result }
    });

    // Если игра завершена
    if (result.isGameComplete) {
      await this.eventBus.publish({
        type: 'GAME_COMPLETED',
        timestamp: Date.now(),
        data: { game, totalTime: game.getPlayTime() }
      });
    }
  }
}
```

### 2. Command Pattern (Команда)

```typescript
// Интерфейс команды
export interface ICommand {
  execute(): Promise<void>;
  undo(): Promise<void>;
  canUndo(): boolean;
}

// Команда для хода в игре
export class MakeMoveCommand implements ICommand {
  constructor(
    private gameId: string,
    private row: number,
    private col: number,
    private newValue: number,
    private oldValue: number,
    private gameRepository: IGameRepository
  ) {}

  async execute(): Promise<void> {
    const game = await this.gameRepository.findById(this.gameId);
    if (!game) throw new GameNotFoundError();

    game.setCell(this.row, this.col, this.newValue);
    await this.gameRepository.save(game);
  }

  async undo(): Promise<void> {
    const game = await this.gameRepository.findById(this.gameId);
    if (!game) throw new GameNotFoundError();

    game.setCell(this.row, this.col, this.oldValue);
    await this.gameRepository.save(game);
  }

  canUndo(): boolean {
    return this.oldValue !== this.newValue;
  }
}

// Команда для использования подсказки
export class UseHintCommand implements ICommand {
  private hintPosition?: { row: number; col: number };
  private hintValue?: number;

  constructor(
    private gameId: string,
    private hintService: IHintService,
    private gameRepository: IGameRepository
  ) {}

  async execute(): Promise<void> {
    const game = await this.gameRepository.findById(this.gameId);
    if (!game) throw new GameNotFoundError();

    const hint = await this.hintService.getBestHint(game.currentGrid);
    if (!hint) throw new NoHintsAvailableError();

    this.hintPosition = { row: hint.row, col: hint.col };
    this.hintValue = hint.value;

    game.setCell(hint.row, hint.col, hint.value);
    game.incrementHintsUsed();

    await this.gameRepository.save(game);
  }

  async undo(): Promise<void> {
    if (!this.hintPosition) return;

    const game = await this.gameRepository.findById(this.gameId);
    if (!game) throw new GameNotFoundError();

    game.setCell(this.hintPosition.row, this.hintPosition.col, 0);
    game.decrementHintsUsed();

    await this.gameRepository.save(game);
  }

  canUndo(): boolean {
    return !!this.hintPosition;
  }
}

// Менеджер команд с поддержкой Undo/Redo
export class CommandManager {
  private history: ICommand[] = [];
  private currentIndex: number = -1;
  private maxHistorySize: number = 50;

  async executeCommand(command: ICommand): Promise<void> {
    await command.execute();

    // Удаляем все команды после текущей позиции
    this.history = this.history.slice(0, this.currentIndex + 1);

    // Добавляем новую команду
    this.history.push(command);
    this.currentIndex++;

    // Ограничиваем размер истории
    if (this.history.length > this.maxHistorySize) {
      this.history.shift();
      this.currentIndex--;
    }
  }

  async undo(): Promise<boolean> {
    if (!this.canUndo()) return false;

    const command = this.history[this.currentIndex];
    await command.undo();
    this.currentIndex--;

    return true;
  }

  async redo(): Promise<boolean> {
    if (!this.canRedo()) return false;

    this.currentIndex++;
    const command = this.history[this.currentIndex];
    await command.execute();

    return true;
  }

  canUndo(): boolean {
    return this.currentIndex >= 0 &&
           this.history[this.currentIndex]?.canUndo();
  }

  canRedo(): boolean {
    return this.currentIndex < this.history.length - 1;
  }

  clear(): void {
    this.history = [];
    this.currentIndex = -1;
  }

  getHistorySize(): number {
    return this.history.length;
  }
}
```

### 3. Strategy Pattern (Стратегия)

```typescript
// Стратегии для разных алгоритмов генерации судоку
export interface IPuzzleGenerationStrategy {
  generate(difficulty: DifficultyLevel): Promise<SudokuPuzzle>;
  getName(): string;
  getEstimatedTime(): number;
}

export class BacktrackingStrategy implements IPuzzleGenerationStrategy {
  getName(): string {
    return 'Backtracking Algorithm';
  }

  getEstimatedTime(): number {
    return 1500; // ms
  }

  async generate(difficulty: DifficultyLevel): Promise<SudokuPuzzle> {
    // Реализация алгоритма backtracking
    const fullGrid = this.generateFullSolution();
    const puzzle = this.removeCellsByDifficulty(fullGrid, difficulty);

    return {
      id: generateUUID(),
      grid: puzzle,
      solution: fullGrid,
      difficulty,
      algorithm: this.getName()
    };
  }

  private generateFullSolution(): SudokuGrid {
    const grid = Array(9).fill(null).map(() => Array(9).fill(0));
    this.fillGrid(grid);
    return grid;
  }

  private fillGrid(grid: SudokuGrid, row = 0, col = 0): boolean {
    if (row === 9) return true;
    if (col === 9) return this.fillGrid(grid, row + 1, 0);

    const numbers = this.shuffleArray([1, 2, 3, 4, 5, 6, 7, 8, 9]);

    for (const num of numbers) {
      if (this.isValidPlacement(grid, row, col, num)) {
        grid[row][col] = num;
        if (this.fillGrid(grid, row, col + 1)) return true;
        grid[row][col] = 0;
      }
    }

    return false;
  }
}

export class ConstraintPropagationStrategy implements IPuzzleGenerationStrategy {
  getName(): string {
    return 'Constraint Propagation';
  }

  getEstimatedTime(): number {
    return 800; // ms - быстрее
  }

  async generate(difficulty: DifficultyLevel): Promise<SudokuPuzzle> {
    // Более эффективный алгоритм с constraint propagation
    const solver = new ConstraintSolver();
    const fullGrid = await solver.generateComplete();
    const puzzle = await solver.createPuzzle(fullGrid, difficulty);

    return {
      id: generateUUID(),
      grid: puzzle,
      solution: fullGrid,
      difficulty,
      algorithm: this.getName()
    };
  }
}

// Контекст стратегии
export class PuzzleGenerator {
  private strategy: IPuzzleGenerationStrategy;

  constructor(strategy: IPuzzleGenerationStrategy) {
    this.strategy = strategy;
  }

  setStrategy(strategy: IPuzzleGenerationStrategy): void {
    this.strategy = strategy;
  }

  async generatePuzzle(difficulty: DifficultyLevel): Promise<SudokuPuzzle> {
    console.log(`Generating puzzle using ${this.strategy.getName()}`);

    const startTime = Date.now();
    const puzzle = await this.strategy.generate(difficulty);
    const endTime = Date.now();

    console.log(`Generated in ${endTime - startTime}ms`);

    return puzzle;
  }

  getEstimatedTime(): number {
    return this.strategy.getEstimatedTime();
  }
}

// Фабрика стратегий
export class StrategyFactory {
  static createStrategy(type: 'backtracking' | 'constraint'): IPuzzleGenerationStrategy {
    switch (type) {
      case 'backtracking':
        return new BacktrackingStrategy();
      case 'constraint':
        return new ConstraintPropagationStrategy();
      default:
        throw new Error(`Unknown strategy type: ${type}`);
    }
  }

  static getBestStrategyForDifficulty(difficulty: DifficultyLevel): IPuzzleGenerationStrategy {
    // Для сложных уровней используем более быстрый алгоритм
    if (difficulty === 'expert' || difficulty === 'hard') {
      return new ConstraintPropagationStrategy();
    }

    return new BacktrackingStrategy();
  }
}
```

---

## 🏭 Креационные паттерны

### 1. Factory Pattern (Фабрика)

```typescript
// Абстрактная фабрика для создания игровых объектов
export abstract class GameObjectFactory {
  abstract createGame(difficulty: DifficultyLevel): GameEntity;
  abstract createPuzzle(difficulty: DifficultyLevel): Promise<SudokuPuzzle>;
  abstract createStatistics(difficulty: DifficultyLevel): StatisticsEntity;
}

// Конкретная фабрика для стандартных игр
export class StandardGameFactory extends GameObjectFactory {
  constructor(
    private puzzleGenerator: IPuzzleGenerationStrategy,
    private rulesEngine: SudokuRules
  ) {
    super();
  }

  createGame(difficulty: DifficultyLevel): GameEntity {
    const id = generateUUID();

    return new GameEntity(
      id,
      [], // будет заполнено при генерации пазла
      [],
      difficulty,
      this.rulesEngine,
      {
        startTime: new Date(),
        hintsRemaining: this.getHintsForDifficulty(difficulty),
        allowedErrors: this.getErrorsForDifficulty(difficulty)
      }
    );
  }

  async createPuzzle(difficulty: DifficultyLevel): Promise<SudokuPuzzle> {
    return await this.puzzleGenerator.generate(difficulty);
  }

  createStatistics(difficulty: DifficultyLevel): StatisticsEntity {
    return new StatisticsEntity(
      difficulty,
      0, // gamesPlayed
      0, // gamesCompleted
      0, // totalTime
      null, // bestTime
      0, // currentStreak
      new Date()
    );
  }

  private getHintsForDifficulty(difficulty: DifficultyLevel): number {
    const hintMap = {
      easy: 10,
      medium: 7,
      hard: 5,
      expert: 3
    };
    return hintMap[difficulty];
  }

  private getErrorsForDifficulty(difficulty: DifficultyLevel): number {
    const errorMap = {
      easy: 5,
      medium: 4,
      hard: 3,
      expert: 2
    };
    return errorMap[difficulty];
  }
}

// Специализированная фабрика для турнирных игр
export class TournamentGameFactory extends GameObjectFactory {
  createGame(difficulty: DifficultyLevel): GameEntity {
    const id = generateUUID();

    return new GameEntity(
      id,
      [],
      [],
      difficulty,
      new TournamentSudokuRules(), // более строгие правила
      {
        startTime: new Date(),
        hintsRemaining: 0, // нет подсказок в турнире
        allowedErrors: 1, // только одна ошибка
        timeLimit: this.getTimeLimitForDifficulty(difficulty)
      }
    );
  }

  async createPuzzle(difficulty: DifficultyLevel): Promise<SudokuPuzzle> {
    // Используем предварительно проверенные пазлы для турниров
    const verifiedPuzzles = await this.getTournamentPuzzles(difficulty);
    return this.selectRandomPuzzle(verifiedPuzzles);
  }

  createStatistics(difficulty: DifficultyLevel): StatisticsEntity {
    return new TournamentStatisticsEntity(
      difficulty,
      0, 0, 0, null, 0,
      new Date(),
      { isTournament: true, ranking: 0 }
    );
  }

  private getTimeLimitForDifficulty(difficulty: DifficultyLevel): number {
    const timeMap = {
      easy: 10 * 60, // 10 минут
      medium: 15 * 60,
      hard: 20 * 60,
      expert: 30 * 60
    };
    return timeMap[difficulty];
  }
}

// Регистр фабрик
export class GameFactoryRegistry {
  private factories = new Map<string, GameObjectFactory>();

  register(type: string, factory: GameObjectFactory): void {
    this.factories.set(type, factory);
  }

  getFactory(type: string): GameObjectFactory {
    const factory = this.factories.get(type);
    if (!factory) {
      throw new Error(`Factory for type ${type} not found`);
    }
    return factory;
  }

  // Фабричный метод для получения фабрики по контексту
  static createFactory(context: GameContext): GameObjectFactory {
    const puzzleStrategy = StrategyFactory.getBestStrategyForDifficulty(
      context.difficulty
    );

    switch (context.gameMode) {
      case 'standard':
        return new StandardGameFactory(puzzleStrategy, new SudokuRules());
      case 'tournament':
        return new TournamentGameFactory();
      default:
        throw new Error(`Unknown game mode: ${context.gameMode}`);
    }
  }
}
```

### 2. Builder Pattern (Строитель)

```typescript
// Builder для создания сложных игровых объектов
export class GameBuilder {
  private game: Partial<GameEntity> = {};
  private options: Partial<GameOptions> = {};

  setDifficulty(difficulty: DifficultyLevel): GameBuilder {
    this.game.difficulty = difficulty;
    return this;
  }

  setPuzzle(puzzle: SudokuPuzzle): GameBuilder {
    this.game.originalGrid = puzzle.grid;
    this.game.currentGrid = puzzle.grid.map(row => [...row]);
    this.game.solution = puzzle.solution;
    return this;
  }

  setMode(mode: GameMode): GameBuilder {
    this.options.gameMode = mode;
    return this;
  }

  setTimer(enabled: boolean, limit?: number): GameBuilder {
    this.options.timerEnabled = enabled;
    this.options.timeLimit = limit;
    return this;
  }

  setHints(count: number): GameBuilder {
    this.options.hintsAvailable = count;
    return this;
  }

  setValidationMode(mode: 'immediate' | 'onComplete' | 'manual'): GameBuilder {
    this.options.validationMode = mode;
    return this;
  }

  setCustomRules(rules: Partial<GameRules>): GameBuilder {
    this.options.customRules = rules;
    return this;
  }

  async build(): Promise<GameEntity> {
    // Валидация обязательных полей
    if (!this.game.difficulty) {
      throw new Error('Difficulty is required');
    }

    // Генерация пазла если не задан
    if (!this.game.originalGrid) {
      const generator = StrategyFactory.getBestStrategyForDifficulty(
        this.game.difficulty
      );
      const puzzle = await generator.generate(this.game.difficulty);
      this.setPuzzle(puzzle);
    }

    // Установка значений по умолчанию
    const gameOptions: GameOptions = {
      gameMode: 'standard',
      timerEnabled: true,
      hintsAvailable: this.getDefaultHints(this.game.difficulty!),
      validationMode: 'immediate',
      ...this.options
    };

    return new GameEntity(
      generateUUID(),
      this.game.originalGrid!,
      this.game.currentGrid!,
      this.game.difficulty!,
      this.createRulesEngine(gameOptions),
      gameOptions
    );
  }

  private getDefaultHints(difficulty: DifficultyLevel): number {
    const hints = { easy: 10, medium: 7, hard: 5, expert: 3 };
    return hints[difficulty];
  }

  private createRulesEngine(options: GameOptions): SudokuRules {
    if (options.customRules) {
      return new CustomSudokuRules(options.customRules);
    }

    return options.gameMode === 'tournament'
      ? new TournamentSudokuRules()
      : new SudokuRules();
  }
}

// Директор для создания предустановленных игр
export class GameDirector {
  constructor(private builder: GameBuilder) {}

  async createQuickGame(difficulty: DifficultyLevel): Promise<GameEntity> {
    return this.builder
      .setDifficulty(difficulty)
      .setMode('standard')
      .setTimer(true)
      .setValidationMode('immediate')
      .build();
  }

  async createTournamentGame(difficulty: DifficultyLevel): Promise<GameEntity> {
    return this.builder
      .setDifficulty(difficulty)
      .setMode('tournament')
      .setTimer(true, 30 * 60) // 30 минут
      .setHints(0) // без подсказок
      .setValidationMode('manual')
      .build();
  }

  async createPracticeGame(difficulty: DifficultyLevel): Promise<GameEntity> {
    return this.builder
      .setDifficulty(difficulty)
      .setMode('practice')
      .setTimer(false)
      .setHints(999) // неограниченные подсказки
      .setValidationMode('immediate')
      .build();
  }

  async createCustomGame(config: CustomGameConfig): Promise<GameEntity> {
    let builder = this.builder
      .setDifficulty(config.difficulty)
      .setMode(config.mode);

    if (config.customPuzzle) {
      builder = builder.setPuzzle(config.customPuzzle);
    }

    if (config.timerConfig) {
      builder = builder.setTimer(
        config.timerConfig.enabled,
        config.timerConfig.limit
      );
    }

    if (config.hintsCount !== undefined) {
      builder = builder.setHints(config.hintsCount);
    }

    if (config.validationMode) {
      builder = builder.setValidationMode(config.validationMode);
    }

    if (config.customRules) {
      builder = builder.setCustomRules(config.customRules);
    }

    return builder.build();
  }
}

// Использование
export class GameService {
  private director: GameDirector;

  constructor() {
    this.director = new GameDirector(new GameBuilder());
  }

  async startQuickGame(difficulty: DifficultyLevel): Promise<GameEntity> {
    return this.director.createQuickGame(difficulty);
  }

  async startCustomGame(config: CustomGameConfig): Promise<GameEntity> {
    return this.director.createCustomGame(config);
  }
}
```

### 3. Singleton Pattern (Одиночка)

```typescript
// Глобальный конфигурационный менеджер
export class GameConfigManager {
  private static instance: GameConfigManager;
  private config: GameConfig;
  private listeners: Array<(config: GameConfig) => void> = [];

  private constructor() {
    this.config = this.loadDefaultConfig();
  }

  static getInstance(): GameConfigManager {
    if (!GameConfigManager.instance) {
      GameConfigManager.instance = new GameConfigManager();
    }
    return GameConfigManager.instance;
  }

  getConfig(): GameConfig {
    return { ...this.config }; // возвращаем копию
  }

  updateConfig(updates: Partial<GameConfig>): void {
    this.config = { ...this.config, ...updates };
    this.notifyListeners();
    this.persistConfig();
  }

  subscribe(listener: (config: GameConfig) => void): () => void {
    this.listeners.push(listener);

    // Возвращаем функцию отписки
    return () => {
      const index = this.listeners.indexOf(listener);
      if (index > -1) {
        this.listeners.splice(index, 1);
      }
    };
  }

  private notifyListeners(): void {
    this.listeners.forEach(listener => listener(this.config));
  }

  private loadDefaultConfig(): GameConfig {
    return {
      difficulty: 'medium',
      theme: 'light',
      soundEnabled: true,
      vibrationsEnabled: true,
      showHints: true,
      showErrors: true,
      autoSave: true,
      language: 'ru'
    };
  }

  private async persistConfig(): Promise<void> {
    try {
      await AsyncStorage.setItem('gameConfig', JSON.stringify(this.config));
    } catch (error) {
      console.error('Failed to persist config:', error);
    }
  }
}

// Analytics Service как Singleton
export class AnalyticsService {
  private static instance: AnalyticsService;
  private isInitialized = false;
  private eventQueue: AnalyticsEvent[] = [];

  private constructor() {}

  static getInstance(): AnalyticsService {
    if (!AnalyticsService.instance) {
      AnalyticsService.instance = new AnalyticsService();
    }
    return AnalyticsService.instance;
  }

  async initialize(): Promise<void> {
    if (this.isInitialized) return;

    // Инициализация Firebase Analytics
    await analytics().setAnalyticsCollectionEnabled(true);

    // Обработка очереди событий
    while (this.eventQueue.length > 0) {
      const event = this.eventQueue.shift()!;
      await this.trackEvent(event.name, event.parameters);
    }

    this.isInitialized = true;
  }

  async trackEvent(eventName: string, parameters?: object): Promise<void> {
    if (!this.isInitialized) {
      // Добавляем в очередь если сервис не инициализирован
      this.eventQueue.push({ name: eventName, parameters });
      return;
    }

    try {
      await analytics().logEvent(eventName, parameters);
    } catch (error) {
      console.error('Analytics error:', error);
    }
  }

  async setUserProperty(name: string, value: string): Promise<void> {
    if (!this.isInitialized) return;

    try {
      await analytics().setUserProperty(name, value);
    } catch (error) {
      console.error('Analytics user property error:', error);
    }
  }
}

// Application State Manager
export class AppStateManager {
  private static instance: AppStateManager;
  private state: AppState;
  private stateListeners: Array<(state: AppState) => void> = [];

  private constructor() {
    this.state = {
      isAppActive: true,
      currentScreen: 'Home',
      networkStatus: 'connected',
      gameInProgress: false,
      lastActiveTime: Date.now()
    };
  }

  static getInstance(): AppStateManager {
    if (!AppStateManager.instance) {
      AppStateManager.instance = new AppStateManager();
    }
    return AppStateManager.instance;
  }

  getState(): AppState {
    return { ...this.state };
  }

  updateState(updates: Partial<AppState>): void {
    this.state = { ...this.state, ...updates };
    this.notifyStateListeners();
  }

  onStateChange(listener: (state: AppState) => void): () => void {
    this.stateListeners.push(listener);

    return () => {
      const index = this.stateListeners.indexOf(listener);
      if (index > -1) {
        this.stateListeners.splice(index, 1);
      }
    };
  }

  private notifyStateListeners(): void {
    this.stateListeners.forEach(listener => listener(this.state));
  }

  // Методы для управления жизненным циклом приложения
  onAppBecomeActive(): void {
    this.updateState({
      isAppActive: true,
      lastActiveTime: Date.now()
    });
  }

  onAppBecomeInactive(): void {
    this.updateState({ isAppActive: false });
  }

  onNetworkChange(isConnected: boolean): void {
    this.updateState({
      networkStatus: isConnected ? 'connected' : 'disconnected'
    });
  }
}
```

---

## 🔧 Структурные паттерны

### 1. Adapter Pattern (Адаптер)

```typescript
// Адаптер для интеграции с различными аналитическими сервисами
export interface IAnalyticsProvider {
  trackEvent(event: string, parameters: object): Promise<void>;
  setUserProperty(key: string, value: string): Promise<void>;
  setUserId(userId: string): Promise<void>;
}

// Firebase Analytics Adapter
export class FirebaseAnalyticsAdapter implements IAnalyticsProvider {
  async trackEvent(event: string, parameters: object): Promise<void> {
    await analytics().logEvent(event, parameters);
  }

  async setUserProperty(key: string, value: string): Promise<void> {
    await analytics().setUserProperty(key, value);
  }

  async setUserId(userId: string): Promise<void> {
    await analytics().setUserId(userId);
  }
}

// Custom Analytics Adapter для собственного сервера
export class CustomAnalyticsAdapter implements IAnalyticsProvider {
  constructor(private apiClient: ApiClient) {}

  async trackEvent(event: string, parameters: object): Promise<void> {
    await this.apiClient.post('/analytics/events', {
      event,
      parameters,
      timestamp: Date.now(),
      sessionId: await this.getSessionId()
    });
  }

  async setUserProperty(key: string, value: string): Promise<void> {
    await this.apiClient.post('/analytics/user-properties', {
      key,
      value,
      userId: await this.getUserId()
    });
  }

  async setUserId(userId: string): Promise<void> {
    await this.apiClient.post('/analytics/user-id', { userId });
  }

  private async getSessionId(): Promise<string> {
    // Получение ID сессии
    return 'session-id';
  }

  private async getUserId(): Promise<string> {
    // Получение ID пользователя
    return 'user-id';
  }
}

// Unified Analytics Service
export class UnifiedAnalyticsService {
  private providers: IAnalyticsProvider[] = [];

  addProvider(provider: IAnalyticsProvider): void {
    this.providers.push(provider);
  }

  async trackGameEvent(event: GameAnalyticsEvent): Promise<void> {
    const promises = this.providers.map(provider =>
      provider.trackEvent(event.name, event.parameters)
    );

    await Promise.allSettled(promises);
  }

  async setUserProperty(key: string, value: string): Promise<void> {
    const promises = this.providers.map(provider =>
      provider.setUserProperty(key, value)
    );

    await Promise.allSettled(promises);
  }
}

// Адаптер для разных форматов сохранения игр
export interface IGameStorageFormat {
  serialize(game: GameEntity): string;
  deserialize(data: string): GameEntity;
  getVersion(): string;
}

export class JSONGameFormatAdapter implements IGameStorageFormat {
  getVersion(): string {
    return '1.0';
  }

  serialize(game: GameEntity): string {
    return JSON.stringify({
      id: game.id,
      difficulty: game.difficulty,
      originalGrid: game.originalGrid,
      currentGrid: game.currentGrid,
      startTime: game.startTime.toISOString(),
      playTime: game.getPlayTime(),
      hintsUsed: game.hintsUsed,
      errorsCount: game.errorsCount,
      version: this.getVersion()
    });
  }

  deserialize(data: string): GameEntity {
    const parsed = JSON.parse(data);

    return new GameEntity(
      parsed.id,
      parsed.originalGrid,
      parsed.currentGrid,
      parsed.difficulty,
      new SudokuRules(),
      {
        startTime: new Date(parsed.startTime),
        hintsUsed: parsed.hintsUsed,
        errorsCount: parsed.errorsCount
      }
    );
  }
}

export class CompressedGameFormatAdapter implements IGameStorageFormat {
  getVersion(): string {
    return '2.0';
  }

  serialize(game: GameEntity): string {
    // Сжатое представление игры
    const compressed = {
      i: game.id,
      d: game.difficulty.charAt(0), // e/m/h/x
      o: this.compressGrid(game.originalGrid),
      c: this.compressGrid(game.currentGrid),
      s: Math.floor(game.startTime.getTime() / 1000),
      p: game.getPlayTime(),
      h: game.hintsUsed,
      e: game.errorsCount,
      v: this.getVersion()
    };

    return JSON.stringify(compressed);
  }

  deserialize(data: string): GameEntity {
    const parsed = JSON.parse(data);

    const difficultyMap: { [key: string]: DifficultyLevel } = {
      e: 'easy', m: 'medium', h: 'hard', x: 'expert'
    };

    return new GameEntity(
      parsed.i,
      this.decompressGrid(parsed.o),
      this.decompressGrid(parsed.c),
      difficultyMap[parsed.d],
      new SudokuRules(),
      {
        startTime: new Date(parsed.s * 1000),
        hintsUsed: parsed.h,
        errorsCount: parsed.e
      }
    );
  }

  private compressGrid(grid: SudokuGrid): string {
    return grid.flat().join('');
  }

  private decompressGrid(compressed: string): SudokuGrid {
    const numbers = compressed.split('').map(Number);
    const grid: SudokuGrid = [];

    for (let i = 0; i < 9; i++) {
      grid[i] = numbers.slice(i * 9, (i + 1) * 9);
    }

    return grid;
  }
}
```

### 2. Facade Pattern (Фасад)

```typescript
// Фасад для игровых операций
export class GameFacade {
  private gameRepository: IGameRepository;
  private puzzleGenerator: IPuzzleGenerationStrategy;
  private commandManager: CommandManager;
  private eventBus: GameEventBus;
  private analyticsService: AnalyticsService;

  constructor(dependencies: GameDependencies) {
    this.gameRepository = dependencies.gameRepository;
    this.puzzleGenerator = dependencies.puzzleGenerator;
    this.commandManager = dependencies.commandManager;
    this.eventBus = dependencies.eventBus;
    this.analyticsService = dependencies.analyticsService;
  }

  // Упрощенный интерфейс для создания новой игры
  async startNewGame(difficulty: DifficultyLevel): Promise<GameInfo> {
    try {
      // 1. Генерируем пазл
      const puzzle = await this.puzzleGenerator.generate(difficulty);

      // 2. Создаем игру
      const factory = GameFactoryRegistry.createFactory({
        difficulty,
        gameMode: 'standard'
      });
      const game = factory.createGame(difficulty);
      game.setPuzzle(puzzle);

      // 3. Сохраняем
      await this.gameRepository.save(game);

      // 4. Очищаем историю команд
      this.commandManager.clear();

      // 5. Отправляем событие
      await this.eventBus.publish({
        type: 'GAME_STARTED',
        timestamp: Date.now(),
        data: { gameId: game.id, difficulty }
      });

      // 6. Трекинг
      await this.analyticsService.trackEvent('game_started', {
        difficulty,
        gameId: game.id
      });

      return {
        id: game.id,
        difficulty: game.difficulty,
        grid: game.currentGrid,
        hintsRemaining: game.getHintsRemaining(),
        canUndo: false
      };

    } catch (error) {
      await this.analyticsService.trackEvent('game_start_error', {
        difficulty,
        error: error.message
      });
      throw error;
    }
  }

  // Упрощенный интерфейс для хода
  async makeMove(gameId: string, row: number, col: number, value: number): Promise<MoveResult> {
    try {
      const game = await this.gameRepository.findById(gameId);
      if (!game) throw new GameNotFoundError();

      const oldValue = game.currentGrid[row][col];

      // Создаем команду
      const command = new MakeMoveCommand(
        gameId, row, col, value, oldValue, this.gameRepository
      );

      // Выполняем через command manager
      await this.commandManager.executeCommand(command);

      // Получаем обновленную игру
      const updatedGame = await this.gameRepository.findById(gameId);
      const isComplete = updatedGame!.isComplete();

      // Отправляем события
      await this.eventBus.publish({
        type: 'MOVE_MADE',
        timestamp: Date.now(),
        data: { gameId, row, col, value, oldValue }
      });

      if (isComplete) {
        await this.eventBus.publish({
          type: 'GAME_COMPLETED',
          timestamp: Date.now(),
          data: { game: updatedGame }
        });
      }

      // Аналитика
      await this.analyticsService.trackEvent('move_made', {
        gameId,
        isComplete,
        moveNumber: updatedGame!.getMoveCount()
      });

      return {
        success: true,
        isComplete,
        canUndo: this.commandManager.canUndo(),
        canRedo: this.commandManager.canRedo(),
        conflictCells: updatedGame!.getConflictCells()
      };

    } catch (error) {
      await this.analyticsService.trackEvent('move_error', {
        gameId,
        error: error.message
      });

      return {
        success: false,
        error: error.message,
        canUndo: this.commandManager.canUndo(),
        canRedo: this.commandManager.canRedo()
      };
    }
  }

  // Упрощенный интерфейс для отмены
  async undoMove(gameId: string): Promise<UndoResult> {
    if (!this.commandManager.canUndo()) {
      return { success: false, reason: 'Nothing to undo' };
    }

    try {
      await this.commandManager.undo();

      await this.eventBus.publish({
        type: 'MOVE_UNDONE',
        timestamp: Date.now(),
        data: { gameId }
      });

      await this.analyticsService.trackEvent('move_undone', { gameId });

      return {
        success: true,
        canUndo: this.commandManager.canUndo(),
        canRedo: this.commandManager.canRedo()
      };

    } catch (error) {
      return {
        success: false,
        reason: error.message
      };
    }
  }

  // Упрощенный интерфейс для подсказки
  async useHint(gameId: string): Promise<HintResult> {
    try {
      const game = await this.gameRepository.findById(gameId);
      if (!game) throw new GameNotFoundError();

      if (game.getHintsRemaining() <= 0) {
        return { success: false, reason: 'No hints remaining' };
      }

      const command = new UseHintCommand(
        gameId,
        new HintService(),
        this.gameRepository
      );

      await this.commandManager.executeCommand(command);

      const hint = await new HintService().getBestHint(game.currentGrid);

      await this.eventBus.publish({
        type: 'HINT_USED',
        timestamp: Date.now(),
        data: { gameId, hint }
      });

      await this.analyticsService.trackEvent('hint_used', {
        gameId,
        hintsRemaining: game.getHintsRemaining() - 1
      });

      return {
        success: true,
        hint: hint!,
        hintsRemaining: game.getHintsRemaining() - 1,
        canUndo: this.commandManager.canUndo()
      };

    } catch (error) {
      return {
        success: false,
        reason: error.message
      };
    }
  }

  // Получение состояния игры
  async getGameState(gameId: string): Promise<GameState> {
    const game = await this.gameRepository.findById(gameId);
    if (!game) throw new GameNotFoundError();

    return {
      id: game.id,
      difficulty: game.difficulty,
      grid: game.currentGrid,
      originalGrid: game.originalGrid,
      isComplete: game.isComplete(),
      playTime: game.getPlayTime(),
      hintsUsed: game.hintsUsed,
      hintsRemaining: game.getHintsRemaining(),
      errorsCount: game.errorsCount,
      canUndo: this.commandManager.canUndo(),
      canRedo: this.commandManager.canRedo(),
      conflictCells: game.getConflictCells()
    };
  }
}

// Фасад для настроек приложения
export class SettingsFacade {
  private settingsRepository: ISettingsRepository;
  private analyticsService: AnalyticsService;
  private configManager: GameConfigManager;

  constructor(dependencies: SettingsDependencies) {
    this.settingsRepository = dependencies.settingsRepository;
    this.analyticsService = dependencies.analyticsService;
    this.configManager = GameConfigManager.getInstance();
  }

  async updateTheme(theme: ThemeName): Promise<void> {
    await this.settingsRepository.updateSetting('theme', theme);
    this.configManager.updateConfig({ theme });

    await this.analyticsService.trackEvent('theme_changed', { theme });
  }

  async updateDifficulty(difficulty: DifficultyLevel): Promise<void> {
    await this.settingsRepository.updateSetting('defaultDifficulty', difficulty);
    this.configManager.updateConfig({ difficulty });

    await this.analyticsService.trackEvent('default_difficulty_changed', {
      difficulty
    });
  }

  async toggleSound(enabled: boolean): Promise<void> {
    await this.settingsRepository.updateSetting('soundEnabled', enabled);
    this.configManager.updateConfig({ soundEnabled: enabled });

    await this.analyticsService.trackEvent('sound_toggled', { enabled });
  }

  async getSettings(): Promise<AppSettings> {
    return await this.settingsRepository.getAll();
  }

  async resetToDefaults(): Promise<void> {
    await this.settingsRepository.resetToDefaults();

    const defaultConfig = {
      theme: 'light' as ThemeName,
      difficulty: 'medium' as DifficultyLevel,
      soundEnabled: true,
      vibrationsEnabled: true
    };

    this.configManager.updateConfig(defaultConfig);

    await this.analyticsService.trackEvent('settings_reset');
  }
}
```

### 3. Decorator Pattern (Декоратор)

```typescript
// Базовый интерфейс для игрового движка
export interface IGameEngine {
  makeMove(row: number, col: number, value: number): Promise<MoveResult>;
  validateMove(row: number, col: number, value: number): boolean;
  isComplete(): boolean;
}

// Базовая реализация
export class BasicGameEngine implements IGameEngine {
  constructor(
    private game: GameEntity,
    private rules: SudokuRules
  ) {}

  async makeMove(row: number, col: number, value: number): Promise<MoveResult> {
    const isValid = this.validateMove(row, col, value);

    if (isValid) {
      this.game.currentGrid[row][col] = value;
      return MoveResult.success(this.isComplete());
    }

    return MoveResult.invalid();
  }

  validateMove(row: number, col: number, value: number): boolean {
    return this.rules.isValidMove(this.game.currentGrid, row, col, value);
  }

  isComplete(): boolean {
    return this.rules.isComplete(this.game.currentGrid);
  }
}

// Декоратор для логирования
export class LoggingGameEngineDecorator implements IGameEngine {
  constructor(private engine: IGameEngine) {}

  async makeMove(row: number, col: number, value: number): Promise<MoveResult> {
    console.log(`Making move: (${row}, ${col}) = ${value}`);
    const startTime = Date.now();

    const result = await this.engine.makeMove(row, col, value);

    const endTime = Date.now();
    console.log(`Move completed in ${endTime - startTime}ms, result:`, result);

    return result;
  }

  validateMove(row: number, col: number, value: number): boolean {
    const isValid = this.engine.validateMove(row, col, value);
    console.log(`Validation: (${row}, ${col}) = ${value} -> ${isValid}`);
    return isValid;
  }

  isComplete(): boolean {
    const complete = this.engine.isComplete();
    console.log(`Game complete check: ${complete}`);
    return complete;
  }
}

// Декоратор для аналитики
export class AnalyticsGameEngineDecorator implements IGameEngine {
  constructor(
    private engine: IGameEngine,
    private analytics: AnalyticsService
  ) {}

  async makeMove(row: number, col: number, value: number): Promise<MoveResult> {
    const result = await this.engine.makeMove(row, col, value);

    await this.analytics.trackEvent('game_move', {
      position: `${row},${col}`,
      value,
      success: result.success,
      gameComplete: result.isComplete
    });

    if (result.isComplete) {
      await this.analytics.trackEvent('game_completed', {
        completion_time: Date.now()
      });
    }

    return result;
  }

  validateMove(row: number, col: number, value: number): boolean {
    return this.engine.validateMove(row, col, value);
  }

  isComplete(): boolean {
    return this.engine.isComplete();
  }
}

// Декоратор для валидации с подсказками
export class HintValidationDecorator implements IGameEngine {
  constructor(
    private engine: IGameEngine,
    private hintService: IHintService
  ) {}

  async makeMove(row: number, col: number, value: number): Promise<MoveResult> {
    const result = await this.engine.makeMove(row, col, value);

    if (!result.success) {
      // Предлагаем подсказку при неправильном ходе
      const hint = await this.hintService.getBestHint(
        this.getCurrentGrid()
      );

      if (hint) {
        result.suggestedHint = hint;
      }
    }

    return result;
  }

  validateMove(row: number, col: number, value: number): boolean {
    return this.engine.validateMove(row, col, value);
  }

  isComplete(): boolean {
    return this.engine.isComplete();
  }

  private getCurrentGrid(): SudokuGrid {
    // Получение текущего состояния сетки
    return []; // placeholder
  }
}

// Декоратор для ограничения времени
export class TimeLimitDecorator implements IGameEngine {
  private startTime: number;
  private timeLimit: number;

  constructor(
    private engine: IGameEngine,
    timeLimitSeconds: number
  ) {
    this.startTime = Date.now();
    this.timeLimit = timeLimitSeconds * 1000;
  }

  async makeMove(row: number, col: number, value: number): Promise<MoveResult> {
    if (this.isTimeExpired()) {
      return MoveResult.timeExpired();
    }

    return await this.engine.makeMove(row, col, value);
  }

  validateMove(row: number, col: number, value: number): boolean {
    if (this.isTimeExpired()) {
      return false;
    }

    return this.engine.validateMove(row, col, value);
  }

  isComplete(): boolean {
    return this.engine.isComplete();
  }

  private isTimeExpired(): boolean {
    return (Date.now() - this.startTime) > this.timeLimit;
  }

  getRemainingTime(): number {
    const elapsed = Date.now() - this.startTime;
    return Math.max(0, this.timeLimit - elapsed);
  }
}

// Фабрика для создания декорированных движков
export class GameEngineFactory {
  static createEngine(
    game: GameEntity,
    options: GameEngineOptions
  ): IGameEngine {
    let engine: IGameEngine = new BasicGameEngine(game, new SudokuRules());

    // Применяем декораторы в зависимости от опций
    if (options.enableLogging) {
      engine = new LoggingGameEngineDecorator(engine);
    }

    if (options.enableAnalytics) {
      engine = new AnalyticsGameEngineDecorator(
        engine,
        AnalyticsService.getInstance()
      );
    }

    if (options.enableHints) {
      engine = new HintValidationDecorator(
        engine,
        new HintService()
      );
    }

    if (options.timeLimit) {
      engine = new TimeLimitDecorator(engine, options.timeLimit);
    }

    return engine;
  }
}
```

---

## ✅ Критерии готовности паттернов

**Паттерны проектирования считаются готовыми, когда:**

1. ✅ **Архитектурные паттерны** - Clean Architecture, Repository, DI
2. ✅ **Поведенческие паттерны** - Observer, Command, Strategy
3. ✅ **Креационные паттерны** - Factory, Builder, Singleton
4. ✅ **Структурные паттерны** - Adapter, Facade, Decorator
5. ✅ **TypeScript реализации** - полные примеры кода
6. ✅ **Интеграция с React Native** - адаптация под мобильную платформу
7. ✅ **Тестируемость** - паттерны упрощают unit testing
8. ✅ **Производительность** - оптимизация для мобильных устройств

### Покрытие паттернами

- **Архитектурные**: 3/3 (Clean Architecture, Repository, DI)
- **Поведенческие**: 3/3 (Observer, Command, Strategy)
- **Креационные**: 3/3 (Factory, Builder, Singleton)
- **Структурные**: 3/3 (Adapter, Facade, Decorator)
- **Специализированные**: Event Bus, Command Manager, Game Engine

---

## 🚀 Следующие шаги

После утверждения паттернов проектирования:

1. **3.1.1** - Настройка проекта и среды разработки
2. **3.1.2** - Создание базовой структуры проекта
3. **3.2.1** - Реализация алгоритма генерации судоку
4. **3.2.2** - Реализация алгоритма решения судоку
5. **3.3.1** - Создание основных экранов приложения

---

**Последнее обновление**: 19 сентября 2025
**Статус**: ✅ Завершено