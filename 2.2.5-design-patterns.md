# 2.2.5 ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ğ¾Ğ² Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ

## Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾
**Ğ”Ğ°Ñ‚Ğ° Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ°**: 19 ÑĞµĞ½Ñ‚ÑĞ±Ñ€Ñ 2025
**Ğ”Ğ°Ñ‚Ğ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ**: 19 ÑĞµĞ½Ñ‚ÑĞ±Ñ€Ñ 2025
**ĞÑ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğ¹**: voleum

---

## ĞĞ±Ñ‰Ğ°Ñ Ñ„Ğ¸Ğ»Ğ¾ÑĞ¾Ñ„Ğ¸Ñ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ğ¾Ğ²

### ğŸ¯ ĞŸÑ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ñ‹ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ğ¾Ğ²

**ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ ĞºÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸Ğ¸:**
1. **SOLID Ğ¿Ñ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ñ‹** - ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²Ğ¸Ğµ Ğ¿Ñ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ğ°Ğ¼ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ½Ğ¾-Ğ¾Ñ€Ğ¸ĞµĞ½Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½Ğ°
2. **ĞŸÑ€Ğ¾ÑÑ‚Ğ¾Ñ‚Ğ° Ğ¸ Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼Ğ¾ÑÑ‚ÑŒ** - Ğ¸Ğ·Ğ±ĞµĞ³Ğ°Ğ½Ğ¸Ğµ overengineering
3. **Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼Ğ¾ÑÑ‚ÑŒ** - Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ ÑƒĞ¿Ñ€Ğ¾Ñ‰Ğ°Ñ‚ÑŒ unit testing
4. **Performance** - Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ½Ğ°ĞºĞ»Ğ°Ğ´Ğ½Ñ‹Ğµ Ñ€Ğ°ÑÑ…Ğ¾Ğ´Ñ‹ Ğ´Ğ»Ñ Ğ¼Ğ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ¹ Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ñ‹
5. **React Native ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ** - Ğ°Ğ´Ğ°Ğ¿Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾Ğ´ ÑĞºĞ¾ÑĞ¸ÑÑ‚ĞµĞ¼Ñƒ React

**ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ½Ğ°Ñ Ğ¸ĞµÑ€Ğ°Ñ€Ñ…Ğ¸Ñ:**
```
Clean Architecture (ĞĞ±Ñ‰Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°)
    â†“
Repository Pattern (Ğ¡Ğ»Ğ¾Ğ¹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…)
    â†“
Dependency Injection (Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ÑĞ¼Ğ¸)
    â†“
ĞšĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹ Ğ¿Ğ¾ ÑĞ»Ğ¾ÑĞ¼
```

---

## ğŸ—ï¸ ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹

### 1. Clean Architecture (Ğ§Ğ¸ÑÑ‚Ğ°Ñ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°)

```typescript
// ĞĞ±Ñ‰Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° ÑĞ»Ğ¾ĞµĞ²
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      CLEAN ARCHITECTURE                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                   ENTITIES (Ğ¡ÑƒÑ‰Ğ½Ğ¾ÑÑ‚Ğ¸)                      â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚
â”‚  â”‚  â”‚     Game      â”‚    Cell     â”‚      Statistics         â”‚  â”‚    â”‚
â”‚  â”‚  â”‚               â”‚             â”‚                         â”‚  â”‚    â”‚
â”‚  â”‚  â”‚- id           â”‚- value      â”‚- gamesPlayed            â”‚  â”‚    â”‚
â”‚  â”‚  â”‚- grid         â”‚- isFixed    â”‚- averageTime            â”‚  â”‚    â”‚
â”‚  â”‚  â”‚- difficulty   â”‚- notes      â”‚- bestTime               â”‚  â”‚    â”‚
â”‚  â”‚  â”‚- rules        â”‚- validate() â”‚- updateStats()          â”‚  â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                              â†‘                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                  USE CASES (Ğ’Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ñ‹ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ)        â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚
â”‚  â”‚  â”‚ StartNewGame  â”‚  MakeMove   â”‚     UseHint             â”‚  â”‚    â”‚
â”‚  â”‚  â”‚               â”‚             â”‚                         â”‚  â”‚    â”‚
â”‚  â”‚  â”‚- validate()   â”‚- validate() â”‚- findBestHint()         â”‚  â”‚    â”‚
â”‚  â”‚  â”‚- generate()   â”‚- apply()    â”‚- applyHint()            â”‚  â”‚    â”‚
â”‚  â”‚  â”‚- save()       â”‚- checkWin() â”‚- updateScore()          â”‚  â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                              â†‘                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                INTERFACE ADAPTERS (ĞĞ´Ğ°Ğ¿Ñ‚ĞµÑ€Ñ‹)               â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚
â”‚  â”‚  â”‚  Controllers  â”‚ Presenters  â”‚     Gateways            â”‚  â”‚    â”‚
â”‚  â”‚  â”‚               â”‚             â”‚                         â”‚  â”‚    â”‚
â”‚  â”‚  â”‚- GameControllerâ”‚- GameVM     â”‚- IGameRepository        â”‚  â”‚    â”‚
â”‚  â”‚  â”‚- InputHandler â”‚- StatsVM    â”‚- ISettingsStorage       â”‚  â”‚    â”‚
â”‚  â”‚  â”‚- EventHandler â”‚- UIState    â”‚- IAnalyticsService      â”‚  â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                              â†‘                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚               FRAMEWORKS & DRIVERS (Ğ¤Ñ€ĞµĞ¹Ğ¼Ğ²Ğ¾Ñ€ĞºĞ¸)            â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚
â”‚  â”‚  â”‚      UI       â”‚  Database   â”‚      External           â”‚  â”‚    â”‚
â”‚  â”‚  â”‚               â”‚             â”‚                         â”‚  â”‚    â”‚
â”‚  â”‚  â”‚- React Native â”‚- SQLite     â”‚- Firebase               â”‚  â”‚    â”‚
â”‚  â”‚  â”‚- Navigation   â”‚- AsyncStore â”‚- Push Notifications     â”‚  â”‚    â”‚
â”‚  â”‚  â”‚- Animations   â”‚- MMKV       â”‚- Analytics              â”‚  â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ² TypeScript:**

```typescript
// Domain Layer - Business Entities
export class GameEntity {
  constructor(
    public readonly id: string,
    public readonly originalGrid: SudokuGrid,
    public currentGrid: SudokuGrid,
    public readonly difficulty: DifficultyLevel,
    public readonly rules: SudokuRules
  ) {}

  makeMove(row: number, col: number, value: number): MoveResult {
    // Ğ‘Ğ¸Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ğ¸ĞºĞ° Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸ Ñ…Ğ¾Ğ´Ğ°
    if (!this.rules.isValidMove(this.currentGrid, row, col, value)) {
      return MoveResult.invalid();
    }

    this.currentGrid[row][col] = value;

    if (this.rules.isComplete(this.currentGrid)) {
      return MoveResult.gameComplete();
    }

    return MoveResult.success();
  }
}

// Use Cases Layer - Application Business Rules
export class MakeMoveUseCase {
  constructor(
    private gameRepository: IGameRepository,
    private analyticsService: IAnalyticsService
  ) {}

  async execute(request: MakeMoveRequest): Promise<MakeMoveResponse> {
    // 1. ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¸Ğ³Ñ€Ñƒ
    const game = await this.gameRepository.findById(request.gameId);
    if (!game) throw new GameNotFoundError();

    // 2. ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ÑĞµĞ¼ Ñ…Ğ¾Ğ´
    const result = game.makeMove(request.row, request.col, request.value);

    // 3. Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ
    await this.gameRepository.save(game);

    // 4. Ğ›Ğ¾Ğ³Ğ¸Ñ€ÑƒĞµĞ¼ Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºÑƒ
    await this.analyticsService.trackMove(request);

    return MakeMoveResponse.from(result);
  }
}

// Interface Adapters Layer - Convert data between layers
export class GameController {
  constructor(private makeMoveUseCase: MakeMoveUseCase) {}

  async handleMove(dto: MakeMoveDTO): Promise<GameStateDTO> {
    const request = MakeMoveRequest.from(dto);
    const response = await this.makeMoveUseCase.execute(request);
    return GameStateDTO.from(response);
  }
}
```

### 2. Repository Pattern (Ğ ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ¹)

```typescript
// Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ñ€ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ñ (Domain Layer)
export interface IGameRepository {
  findById(id: string): Promise<GameEntity | null>;
  findByUser(userId: string): Promise<GameEntity[]>;
  save(game: GameEntity): Promise<void>;
  delete(id: string): Promise<void>;
  findActive(): Promise<GameEntity[]>;
}

// Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ñ€ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ñ (Infrastructure Layer)
export class SQLiteGameRepository implements IGameRepository {
  constructor(
    private database: SQLiteDatabase,
    private mapper: GameEntityMapper
  ) {}

  async findById(id: string): Promise<GameEntity | null> {
    const query = 'SELECT * FROM games WHERE id = ?';
    const result = await this.database.executeSql(query, [id]);

    if (result[0].rows.length === 0) return null;

    const row = result[0].rows.item(0);
    return this.mapper.toDomain(row);
  }

  async save(game: GameEntity): Promise<void> {
    const data = this.mapper.toPersistence(game);

    const query = `
      INSERT OR REPLACE INTO games
      (id, difficulty, original_grid, current_grid, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?)
    `;

    await this.database.executeSql(query, [
      data.id, data.difficulty, data.originalGrid,
      data.currentGrid, data.createdAt, Date.now()
    ]);
  }

  async findActive(): Promise<GameEntity[]> {
    const query = `
      SELECT * FROM games
      WHERE status IN ('active', 'paused')
      ORDER BY last_played_at DESC
    `;

    const result = await this.database.executeSql(query);
    return this.mapper.toDomainList(result[0].rows);
  }
}

// Composition Root - Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹
export class DependencyContainer {
  register(): void {
    // Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ñ€ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ñ
    this.container.register<IGameRepository>(
      'GameRepository',
      () => new SQLiteGameRepository(
        this.container.resolve('Database'),
        this.container.resolve('GameMapper')
      )
    );
  }
}
```

### 3. Dependency Injection (Ğ’Ğ½ĞµĞ´Ñ€ĞµĞ½Ğ¸Ğµ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹)

```typescript
// IoC Container Ğ´Ğ»Ñ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ÑĞ¼Ğ¸
export class DIContainer {
  private dependencies = new Map<string, any>();
  private singletons = new Map<string, any>();

  register<T>(
    token: string,
    factory: () => T,
    lifetime: 'singleton' | 'transient' = 'transient'
  ): void {
    this.dependencies.set(token, { factory, lifetime });
  }

  resolve<T>(token: string): T {
    const dependency = this.dependencies.get(token);
    if (!dependency) {
      throw new Error(`Dependency ${token} not registered`);
    }

    if (dependency.lifetime === 'singleton') {
      if (!this.singletons.has(token)) {
        this.singletons.set(token, dependency.factory());
      }
      return this.singletons.get(token);
    }

    return dependency.factory();
  }
}

// Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹
export class ServiceRegistration {
  static register(container: DIContainer): void {
    // Infrastructure
    container.register('Database', () =>
      SQLite.openDatabase({ name: 'sudoku.db' }), 'singleton'
    );

    // Repositories
    container.register<IGameRepository>('GameRepository', () =>
      new SQLiteGameRepository(
        container.resolve('Database'),
        container.resolve('GameMapper')
      )
    );

    // Use Cases
    container.register('MakeMoveUseCase', () =>
      new MakeMoveUseCase(
        container.resolve('GameRepository'),
        container.resolve('AnalyticsService')
      )
    );

    // Mappers
    container.register('GameMapper', () => new GameEntityMapper());
  }
}

// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ² React ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ°Ñ…
export const useGameService = () => {
  return container.resolve<MakeMoveUseCase>('MakeMoveUseCase');
};
```

---

## ğŸ“ ĞŸĞ¾Ğ²ĞµĞ´ĞµĞ½Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹

### 1. Observer Pattern (ĞĞ°Ğ±Ğ»ÑĞ´Ğ°Ñ‚ĞµĞ»ÑŒ)

```typescript
// Event-driven Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ğ¸Ğ³Ñ€Ğ¾Ğ²Ñ‹Ñ… ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğ¹
export interface GameEvent {
  type: string;
  timestamp: number;
  data: any;
}

export interface IGameEventObserver {
  handle(event: GameEvent): Promise<void>;
}

export class GameEventBus {
  private observers = new Map<string, IGameEventObserver[]>();

  subscribe(eventType: string, observer: IGameEventObserver): void {
    if (!this.observers.has(eventType)) {
      this.observers.set(eventType, []);
    }
    this.observers.get(eventType)!.push(observer);
  }

  async publish(event: GameEvent): Promise<void> {
    const observers = this.observers.get(event.type) || [];

    // ĞŸĞ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»ÑŒĞ½Ğ°Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğ¹
    await Promise.all(
      observers.map(observer => observer.handle(event))
    );
  }

  unsubscribe(eventType: string, observer: IGameEventObserver): void {
    const observers = this.observers.get(eventType) || [];
    const index = observers.indexOf(observer);
    if (index > -1) {
      observers.splice(index, 1);
    }
  }
}

// ĞšĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ñ‹Ğµ Ğ½Ğ°Ğ±Ğ»ÑĞ´Ğ°Ñ‚ĞµĞ»Ğ¸
export class StatisticsUpdateObserver implements IGameEventObserver {
  constructor(private statisticsService: IStatisticsService) {}

  async handle(event: GameEvent): Promise<void> {
    switch (event.type) {
      case 'GAME_COMPLETED':
        await this.statisticsService.recordGameCompletion(event.data);
        break;
      case 'MOVE_MADE':
        await this.statisticsService.recordMove(event.data);
        break;
      case 'HINT_USED':
        await this.statisticsService.recordHintUsage(event.data);
        break;
    }
  }
}

export class AchievementObserver implements IGameEventObserver {
  constructor(private achievementService: IAchievementService) {}

  async handle(event: GameEvent): Promise<void> {
    if (event.type === 'GAME_COMPLETED') {
      await this.achievementService.checkAchievements(event.data);
    }
  }
}

// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ² Use Case
export class MakeMoveUseCase {
  constructor(
    private gameRepository: IGameRepository,
    private eventBus: GameEventBus
  ) {}

  async execute(request: MakeMoveRequest): Promise<void> {
    // Ğ”ĞµĞ»Ğ°ĞµĞ¼ Ñ…Ğ¾Ğ´
    const game = await this.gameRepository.findById(request.gameId);
    const result = game.makeMove(request.row, request.col, request.value);

    await this.gameRepository.save(game);

    // ĞŸÑƒĞ±Ğ»Ğ¸ĞºÑƒĞµĞ¼ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğµ
    await this.eventBus.publish({
      type: 'MOVE_MADE',
      timestamp: Date.now(),
      data: { gameId: game.id, move: request, result }
    });

    // Ğ•ÑĞ»Ğ¸ Ğ¸Ğ³Ñ€Ğ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°
    if (result.isGameComplete) {
      await this.eventBus.publish({
        type: 'GAME_COMPLETED',
        timestamp: Date.now(),
        data: { game, totalTime: game.getPlayTime() }
      });
    }
  }
}
```

### 2. Command Pattern (ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ°)

```typescript
// Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹
export interface ICommand {
  execute(): Promise<void>;
  undo(): Promise<void>;
  canUndo(): boolean;
}

// ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° Ğ´Ğ»Ñ Ñ…Ğ¾Ğ´Ğ° Ğ² Ğ¸Ğ³Ñ€Ğµ
export class MakeMoveCommand implements ICommand {
  constructor(
    private gameId: string,
    private row: number,
    private col: number,
    private newValue: number,
    private oldValue: number,
    private gameRepository: IGameRepository
  ) {}

  async execute(): Promise<void> {
    const game = await this.gameRepository.findById(this.gameId);
    if (!game) throw new GameNotFoundError();

    game.setCell(this.row, this.col, this.newValue);
    await this.gameRepository.save(game);
  }

  async undo(): Promise<void> {
    const game = await this.gameRepository.findById(this.gameId);
    if (!game) throw new GameNotFoundError();

    game.setCell(this.row, this.col, this.oldValue);
    await this.gameRepository.save(game);
  }

  canUndo(): boolean {
    return this.oldValue !== this.newValue;
  }
}

// ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° Ğ´Ğ»Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¿Ğ¾Ğ´ÑĞºĞ°Ğ·ĞºĞ¸
export class UseHintCommand implements ICommand {
  private hintPosition?: { row: number; col: number };
  private hintValue?: number;

  constructor(
    private gameId: string,
    private hintService: IHintService,
    private gameRepository: IGameRepository
  ) {}

  async execute(): Promise<void> {
    const game = await this.gameRepository.findById(this.gameId);
    if (!game) throw new GameNotFoundError();

    const hint = await this.hintService.getBestHint(game.currentGrid);
    if (!hint) throw new NoHintsAvailableError();

    this.hintPosition = { row: hint.row, col: hint.col };
    this.hintValue = hint.value;

    game.setCell(hint.row, hint.col, hint.value);
    game.incrementHintsUsed();

    await this.gameRepository.save(game);
  }

  async undo(): Promise<void> {
    if (!this.hintPosition) return;

    const game = await this.gameRepository.findById(this.gameId);
    if (!game) throw new GameNotFoundError();

    game.setCell(this.hintPosition.row, this.hintPosition.col, 0);
    game.decrementHintsUsed();

    await this.gameRepository.save(game);
  }

  canUndo(): boolean {
    return !!this.hintPosition;
  }
}

// ĞœĞµĞ½ĞµĞ´Ğ¶ĞµÑ€ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´ Ñ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ¾Ğ¹ Undo/Redo
export class CommandManager {
  private history: ICommand[] = [];
  private currentIndex: number = -1;
  private maxHistorySize: number = 50;

  async executeCommand(command: ICommand): Promise<void> {
    await command.execute();

    // Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ²ÑĞµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ Ğ¿Ğ¾ÑĞ»Ğµ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¹ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
    this.history = this.history.slice(0, this.currentIndex + 1);

    // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²ÑƒÑ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ
    this.history.push(command);
    this.currentIndex++;

    // ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸
    if (this.history.length > this.maxHistorySize) {
      this.history.shift();
      this.currentIndex--;
    }
  }

  async undo(): Promise<boolean> {
    if (!this.canUndo()) return false;

    const command = this.history[this.currentIndex];
    await command.undo();
    this.currentIndex--;

    return true;
  }

  async redo(): Promise<boolean> {
    if (!this.canRedo()) return false;

    this.currentIndex++;
    const command = this.history[this.currentIndex];
    await command.execute();

    return true;
  }

  canUndo(): boolean {
    return this.currentIndex >= 0 &&
           this.history[this.currentIndex]?.canUndo();
  }

  canRedo(): boolean {
    return this.currentIndex < this.history.length - 1;
  }

  clear(): void {
    this.history = [];
    this.currentIndex = -1;
  }

  getHistorySize(): number {
    return this.history.length;
  }
}
```

### 3. Strategy Pattern (Ğ¡Ñ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ñ)

```typescript
// Ğ¡Ñ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ğ¸ Ğ´Ğ»Ñ Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğ¾Ğ² Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ ÑÑƒĞ´Ğ¾ĞºÑƒ
export interface IPuzzleGenerationStrategy {
  generate(difficulty: DifficultyLevel): Promise<SudokuPuzzle>;
  getName(): string;
  getEstimatedTime(): number;
}

export class BacktrackingStrategy implements IPuzzleGenerationStrategy {
  getName(): string {
    return 'Backtracking Algorithm';
  }

  getEstimatedTime(): number {
    return 1500; // ms
  }

  async generate(difficulty: DifficultyLevel): Promise<SudokuPuzzle> {
    // Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğ° backtracking
    const fullGrid = this.generateFullSolution();
    const puzzle = this.removeCellsByDifficulty(fullGrid, difficulty);

    return {
      id: generateUUID(),
      grid: puzzle,
      solution: fullGrid,
      difficulty,
      algorithm: this.getName()
    };
  }

  private generateFullSolution(): SudokuGrid {
    const grid = Array(9).fill(null).map(() => Array(9).fill(0));
    this.fillGrid(grid);
    return grid;
  }

  private fillGrid(grid: SudokuGrid, row = 0, col = 0): boolean {
    if (row === 9) return true;
    if (col === 9) return this.fillGrid(grid, row + 1, 0);

    const numbers = this.shuffleArray([1, 2, 3, 4, 5, 6, 7, 8, 9]);

    for (const num of numbers) {
      if (this.isValidPlacement(grid, row, col, num)) {
        grid[row][col] = num;
        if (this.fillGrid(grid, row, col + 1)) return true;
        grid[row][col] = 0;
      }
    }

    return false;
  }
}

export class ConstraintPropagationStrategy implements IPuzzleGenerationStrategy {
  getName(): string {
    return 'Constraint Propagation';
  }

  getEstimatedTime(): number {
    return 800; // ms - Ğ±Ñ‹ÑÑ‚Ñ€ĞµĞµ
  }

  async generate(difficulty: DifficultyLevel): Promise<SudokuPuzzle> {
    // Ğ‘Ğ¾Ğ»ĞµĞµ ÑÑ„Ñ„ĞµĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼ Ñ constraint propagation
    const solver = new ConstraintSolver();
    const fullGrid = await solver.generateComplete();
    const puzzle = await solver.createPuzzle(fullGrid, difficulty);

    return {
      id: generateUUID(),
      grid: puzzle,
      solution: fullGrid,
      difficulty,
      algorithm: this.getName()
    };
  }
}

// ĞšĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚ ÑÑ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ğ¸
export class PuzzleGenerator {
  private strategy: IPuzzleGenerationStrategy;

  constructor(strategy: IPuzzleGenerationStrategy) {
    this.strategy = strategy;
  }

  setStrategy(strategy: IPuzzleGenerationStrategy): void {
    this.strategy = strategy;
  }

  async generatePuzzle(difficulty: DifficultyLevel): Promise<SudokuPuzzle> {
    console.log(`Generating puzzle using ${this.strategy.getName()}`);

    const startTime = Date.now();
    const puzzle = await this.strategy.generate(difficulty);
    const endTime = Date.now();

    console.log(`Generated in ${endTime - startTime}ms`);

    return puzzle;
  }

  getEstimatedTime(): number {
    return this.strategy.getEstimatedTime();
  }
}

// Ğ¤Ğ°Ğ±Ñ€Ğ¸ĞºĞ° ÑÑ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ğ¹
export class StrategyFactory {
  static createStrategy(type: 'backtracking' | 'constraint'): IPuzzleGenerationStrategy {
    switch (type) {
      case 'backtracking':
        return new BacktrackingStrategy();
      case 'constraint':
        return new ConstraintPropagationStrategy();
      default:
        throw new Error(`Unknown strategy type: ${type}`);
    }
  }

  static getBestStrategyForDifficulty(difficulty: DifficultyLevel): IPuzzleGenerationStrategy {
    // Ğ”Ğ»Ñ ÑĞ»Ğ¾Ğ¶Ğ½Ñ‹Ñ… ÑƒÑ€Ğ¾Ğ²Ğ½ĞµĞ¹ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ±Ğ¾Ğ»ĞµĞµ Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼
    if (difficulty === 'expert' || difficulty === 'hard') {
      return new ConstraintPropagationStrategy();
    }

    return new BacktrackingStrategy();
  }
}
```

---

## ğŸ­ ĞšÑ€ĞµĞ°Ñ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹

### 1. Factory Pattern (Ğ¤Ğ°Ğ±Ñ€Ğ¸ĞºĞ°)

```typescript
// ĞĞ±ÑÑ‚Ñ€Ğ°ĞºÑ‚Ğ½Ğ°Ñ Ñ„Ğ°Ğ±Ñ€Ğ¸ĞºĞ° Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¸Ğ³Ñ€Ğ¾Ğ²Ñ‹Ñ… Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ¾Ğ²
export abstract class GameObjectFactory {
  abstract createGame(difficulty: DifficultyLevel): GameEntity;
  abstract createPuzzle(difficulty: DifficultyLevel): Promise<SudokuPuzzle>;
  abstract createStatistics(difficulty: DifficultyLevel): StatisticsEntity;
}

// ĞšĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ°Ñ Ñ„Ğ°Ğ±Ñ€Ğ¸ĞºĞ° Ğ´Ğ»Ñ ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ‹Ñ… Ğ¸Ğ³Ñ€
export class StandardGameFactory extends GameObjectFactory {
  constructor(
    private puzzleGenerator: IPuzzleGenerationStrategy,
    private rulesEngine: SudokuRules
  ) {
    super();
  }

  createGame(difficulty: DifficultyLevel): GameEntity {
    const id = generateUUID();

    return new GameEntity(
      id,
      [], // Ğ±ÑƒĞ´ĞµÑ‚ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¾ Ğ¿Ñ€Ğ¸ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ğ¿Ğ°Ğ·Ğ»Ğ°
      [],
      difficulty,
      this.rulesEngine,
      {
        startTime: new Date(),
        hintsRemaining: this.getHintsForDifficulty(difficulty),
        allowedErrors: this.getErrorsForDifficulty(difficulty)
      }
    );
  }

  async createPuzzle(difficulty: DifficultyLevel): Promise<SudokuPuzzle> {
    return await this.puzzleGenerator.generate(difficulty);
  }

  createStatistics(difficulty: DifficultyLevel): StatisticsEntity {
    return new StatisticsEntity(
      difficulty,
      0, // gamesPlayed
      0, // gamesCompleted
      0, // totalTime
      null, // bestTime
      0, // currentStreak
      new Date()
    );
  }

  private getHintsForDifficulty(difficulty: DifficultyLevel): number {
    const hintMap = {
      easy: 10,
      medium: 7,
      hard: 5,
      expert: 3
    };
    return hintMap[difficulty];
  }

  private getErrorsForDifficulty(difficulty: DifficultyLevel): number {
    const errorMap = {
      easy: 5,
      medium: 4,
      hard: 3,
      expert: 2
    };
    return errorMap[difficulty];
  }
}

// Ğ¡Ğ¿ĞµÑ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ Ñ„Ğ°Ğ±Ñ€Ğ¸ĞºĞ° Ğ´Ğ»Ñ Ñ‚ÑƒÑ€Ğ½Ğ¸Ñ€Ğ½Ñ‹Ñ… Ğ¸Ğ³Ñ€
export class TournamentGameFactory extends GameObjectFactory {
  createGame(difficulty: DifficultyLevel): GameEntity {
    const id = generateUUID();

    return new GameEntity(
      id,
      [],
      [],
      difficulty,
      new TournamentSudokuRules(), // Ğ±Ğ¾Ğ»ĞµĞµ ÑÑ‚Ñ€Ğ¾Ğ³Ğ¸Ğµ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ°
      {
        startTime: new Date(),
        hintsRemaining: 0, // Ğ½ĞµÑ‚ Ğ¿Ğ¾Ğ´ÑĞºĞ°Ğ·Ğ¾Ğº Ğ² Ñ‚ÑƒÑ€Ğ½Ğ¸Ñ€Ğµ
        allowedErrors: 1, // Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾Ğ´Ğ½Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°
        timeLimit: this.getTimeLimitForDifficulty(difficulty)
      }
    );
  }

  async createPuzzle(difficulty: DifficultyLevel): Promise<SudokuPuzzle> {
    // Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ¿Ñ€ĞµĞ´Ğ²Ğ°Ñ€Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞµĞ½Ğ½Ñ‹Ğµ Ğ¿Ğ°Ğ·Ğ»Ñ‹ Ğ´Ğ»Ñ Ñ‚ÑƒÑ€Ğ½Ğ¸Ñ€Ğ¾Ğ²
    const verifiedPuzzles = await this.getTournamentPuzzles(difficulty);
    return this.selectRandomPuzzle(verifiedPuzzles);
  }

  createStatistics(difficulty: DifficultyLevel): StatisticsEntity {
    return new TournamentStatisticsEntity(
      difficulty,
      0, 0, 0, null, 0,
      new Date(),
      { isTournament: true, ranking: 0 }
    );
  }

  private getTimeLimitForDifficulty(difficulty: DifficultyLevel): number {
    const timeMap = {
      easy: 10 * 60, // 10 Ğ¼Ğ¸Ğ½ÑƒÑ‚
      medium: 15 * 60,
      hard: 20 * 60,
      expert: 30 * 60
    };
    return timeMap[difficulty];
  }
}

// Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€ Ñ„Ğ°Ğ±Ñ€Ğ¸Ğº
export class GameFactoryRegistry {
  private factories = new Map<string, GameObjectFactory>();

  register(type: string, factory: GameObjectFactory): void {
    this.factories.set(type, factory);
  }

  getFactory(type: string): GameObjectFactory {
    const factory = this.factories.get(type);
    if (!factory) {
      throw new Error(`Factory for type ${type} not found`);
    }
    return factory;
  }

  // Ğ¤Ğ°Ğ±Ñ€Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ Ğ¼ĞµÑ‚Ğ¾Ğ´ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ñ„Ğ°Ğ±Ñ€Ğ¸ĞºĞ¸ Ğ¿Ğ¾ ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ñƒ
  static createFactory(context: GameContext): GameObjectFactory {
    const puzzleStrategy = StrategyFactory.getBestStrategyForDifficulty(
      context.difficulty
    );

    switch (context.gameMode) {
      case 'standard':
        return new StandardGameFactory(puzzleStrategy, new SudokuRules());
      case 'tournament':
        return new TournamentGameFactory();
      default:
        throw new Error(`Unknown game mode: ${context.gameMode}`);
    }
  }
}
```

### 2. Builder Pattern (Ğ¡Ñ‚Ñ€Ğ¾Ğ¸Ñ‚ĞµĞ»ÑŒ)

```typescript
// Builder Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ ÑĞ»Ğ¾Ğ¶Ğ½Ñ‹Ñ… Ğ¸Ğ³Ñ€Ğ¾Ğ²Ñ‹Ñ… Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ¾Ğ²
export class GameBuilder {
  private game: Partial<GameEntity> = {};
  private options: Partial<GameOptions> = {};

  setDifficulty(difficulty: DifficultyLevel): GameBuilder {
    this.game.difficulty = difficulty;
    return this;
  }

  setPuzzle(puzzle: SudokuPuzzle): GameBuilder {
    this.game.originalGrid = puzzle.grid;
    this.game.currentGrid = puzzle.grid.map(row => [...row]);
    this.game.solution = puzzle.solution;
    return this;
  }

  setMode(mode: GameMode): GameBuilder {
    this.options.gameMode = mode;
    return this;
  }

  setTimer(enabled: boolean, limit?: number): GameBuilder {
    this.options.timerEnabled = enabled;
    this.options.timeLimit = limit;
    return this;
  }

  setHints(count: number): GameBuilder {
    this.options.hintsAvailable = count;
    return this;
  }

  setValidationMode(mode: 'immediate' | 'onComplete' | 'manual'): GameBuilder {
    this.options.validationMode = mode;
    return this;
  }

  setCustomRules(rules: Partial<GameRules>): GameBuilder {
    this.options.customRules = rules;
    return this;
  }

  async build(): Promise<GameEntity> {
    // Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ĞµĞ¹
    if (!this.game.difficulty) {
      throw new Error('Difficulty is required');
    }

    // Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ°Ğ·Ğ»Ğ° ĞµÑĞ»Ğ¸ Ğ½Ğµ Ğ·Ğ°Ğ´Ğ°Ğ½
    if (!this.game.originalGrid) {
      const generator = StrategyFactory.getBestStrategyForDifficulty(
        this.game.difficulty
      );
      const puzzle = await generator.generate(this.game.difficulty);
      this.setPuzzle(puzzle);
    }

    // Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğ¹ Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ
    const gameOptions: GameOptions = {
      gameMode: 'standard',
      timerEnabled: true,
      hintsAvailable: this.getDefaultHints(this.game.difficulty!),
      validationMode: 'immediate',
      ...this.options
    };

    return new GameEntity(
      generateUUID(),
      this.game.originalGrid!,
      this.game.currentGrid!,
      this.game.difficulty!,
      this.createRulesEngine(gameOptions),
      gameOptions
    );
  }

  private getDefaultHints(difficulty: DifficultyLevel): number {
    const hints = { easy: 10, medium: 7, hard: 5, expert: 3 };
    return hints[difficulty];
  }

  private createRulesEngine(options: GameOptions): SudokuRules {
    if (options.customRules) {
      return new CustomSudokuRules(options.customRules);
    }

    return options.gameMode === 'tournament'
      ? new TournamentSudokuRules()
      : new SudokuRules();
  }
}

// Ğ”Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€ Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¿Ñ€ĞµĞ´ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ñ… Ğ¸Ğ³Ñ€
export class GameDirector {
  constructor(private builder: GameBuilder) {}

  async createQuickGame(difficulty: DifficultyLevel): Promise<GameEntity> {
    return this.builder
      .setDifficulty(difficulty)
      .setMode('standard')
      .setTimer(true)
      .setValidationMode('immediate')
      .build();
  }

  async createTournamentGame(difficulty: DifficultyLevel): Promise<GameEntity> {
    return this.builder
      .setDifficulty(difficulty)
      .setMode('tournament')
      .setTimer(true, 30 * 60) // 30 Ğ¼Ğ¸Ğ½ÑƒÑ‚
      .setHints(0) // Ğ±ĞµĞ· Ğ¿Ğ¾Ğ´ÑĞºĞ°Ğ·Ğ¾Ğº
      .setValidationMode('manual')
      .build();
  }

  async createPracticeGame(difficulty: DifficultyLevel): Promise<GameEntity> {
    return this.builder
      .setDifficulty(difficulty)
      .setMode('practice')
      .setTimer(false)
      .setHints(999) // Ğ½ĞµĞ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾Ğ´ÑĞºĞ°Ğ·ĞºĞ¸
      .setValidationMode('immediate')
      .build();
  }

  async createCustomGame(config: CustomGameConfig): Promise<GameEntity> {
    let builder = this.builder
      .setDifficulty(config.difficulty)
      .setMode(config.mode);

    if (config.customPuzzle) {
      builder = builder.setPuzzle(config.customPuzzle);
    }

    if (config.timerConfig) {
      builder = builder.setTimer(
        config.timerConfig.enabled,
        config.timerConfig.limit
      );
    }

    if (config.hintsCount !== undefined) {
      builder = builder.setHints(config.hintsCount);
    }

    if (config.validationMode) {
      builder = builder.setValidationMode(config.validationMode);
    }

    if (config.customRules) {
      builder = builder.setCustomRules(config.customRules);
    }

    return builder.build();
  }
}

// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
export class GameService {
  private director: GameDirector;

  constructor() {
    this.director = new GameDirector(new GameBuilder());
  }

  async startQuickGame(difficulty: DifficultyLevel): Promise<GameEntity> {
    return this.director.createQuickGame(difficulty);
  }

  async startCustomGame(config: CustomGameConfig): Promise<GameEntity> {
    return this.director.createCustomGame(config);
  }
}
```

### 3. Singleton Pattern (ĞĞ´Ğ¸Ğ½Ğ¾Ñ‡ĞºĞ°)

```typescript
// Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğ¹ Ğ¼ĞµĞ½ĞµĞ´Ğ¶ĞµÑ€
export class GameConfigManager {
  private static instance: GameConfigManager;
  private config: GameConfig;
  private listeners: Array<(config: GameConfig) => void> = [];

  private constructor() {
    this.config = this.loadDefaultConfig();
  }

  static getInstance(): GameConfigManager {
    if (!GameConfigManager.instance) {
      GameConfigManager.instance = new GameConfigManager();
    }
    return GameConfigManager.instance;
  }

  getConfig(): GameConfig {
    return { ...this.config }; // Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ ĞºĞ¾Ğ¿Ğ¸Ñ
  }

  updateConfig(updates: Partial<GameConfig>): void {
    this.config = { ...this.config, ...updates };
    this.notifyListeners();
    this.persistConfig();
  }

  subscribe(listener: (config: GameConfig) => void): () => void {
    this.listeners.push(listener);

    // Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ¾Ñ‚Ğ¿Ğ¸ÑĞºĞ¸
    return () => {
      const index = this.listeners.indexOf(listener);
      if (index > -1) {
        this.listeners.splice(index, 1);
      }
    };
  }

  private notifyListeners(): void {
    this.listeners.forEach(listener => listener(this.config));
  }

  private loadDefaultConfig(): GameConfig {
    return {
      difficulty: 'medium',
      theme: 'light',
      soundEnabled: true,
      vibrationsEnabled: true,
      showHints: true,
      showErrors: true,
      autoSave: true,
      language: 'ru'
    };
  }

  private async persistConfig(): Promise<void> {
    try {
      await AsyncStorage.setItem('gameConfig', JSON.stringify(this.config));
    } catch (error) {
      console.error('Failed to persist config:', error);
    }
  }
}

// Analytics Service ĞºĞ°Ğº Singleton
export class AnalyticsService {
  private static instance: AnalyticsService;
  private isInitialized = false;
  private eventQueue: AnalyticsEvent[] = [];

  private constructor() {}

  static getInstance(): AnalyticsService {
    if (!AnalyticsService.instance) {
      AnalyticsService.instance = new AnalyticsService();
    }
    return AnalyticsService.instance;
  }

  async initialize(): Promise<void> {
    if (this.isInitialized) return;

    // Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Firebase Analytics
    await analytics().setAnalyticsCollectionEnabled(true);

    // ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¾Ñ‡ĞµÑ€ĞµĞ´Ğ¸ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğ¹
    while (this.eventQueue.length > 0) {
      const event = this.eventQueue.shift()!;
      await this.trackEvent(event.name, event.parameters);
    }

    this.isInitialized = true;
  }

  async trackEvent(eventName: string, parameters?: object): Promise<void> {
    if (!this.isInitialized) {
      // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ² Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑŒ ĞµÑĞ»Ğ¸ ÑĞµÑ€Ğ²Ğ¸Ñ Ğ½Ğµ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½
      this.eventQueue.push({ name: eventName, parameters });
      return;
    }

    try {
      await analytics().logEvent(eventName, parameters);
    } catch (error) {
      console.error('Analytics error:', error);
    }
  }

  async setUserProperty(name: string, value: string): Promise<void> {
    if (!this.isInitialized) return;

    try {
      await analytics().setUserProperty(name, value);
    } catch (error) {
      console.error('Analytics user property error:', error);
    }
  }
}

// Application State Manager
export class AppStateManager {
  private static instance: AppStateManager;
  private state: AppState;
  private stateListeners: Array<(state: AppState) => void> = [];

  private constructor() {
    this.state = {
      isAppActive: true,
      currentScreen: 'Home',
      networkStatus: 'connected',
      gameInProgress: false,
      lastActiveTime: Date.now()
    };
  }

  static getInstance(): AppStateManager {
    if (!AppStateManager.instance) {
      AppStateManager.instance = new AppStateManager();
    }
    return AppStateManager.instance;
  }

  getState(): AppState {
    return { ...this.state };
  }

  updateState(updates: Partial<AppState>): void {
    this.state = { ...this.state, ...updates };
    this.notifyStateListeners();
  }

  onStateChange(listener: (state: AppState) => void): () => void {
    this.stateListeners.push(listener);

    return () => {
      const index = this.stateListeners.indexOf(listener);
      if (index > -1) {
        this.stateListeners.splice(index, 1);
      }
    };
  }

  private notifyStateListeners(): void {
    this.stateListeners.forEach(listener => listener(this.state));
  }

  // ĞœĞµÑ‚Ğ¾Ğ´Ñ‹ Ğ´Ğ»Ñ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¶Ğ¸Ğ·Ğ½ĞµĞ½Ğ½Ñ‹Ğ¼ Ñ†Ğ¸ĞºĞ»Ğ¾Ğ¼ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
  onAppBecomeActive(): void {
    this.updateState({
      isAppActive: true,
      lastActiveTime: Date.now()
    });
  }

  onAppBecomeInactive(): void {
    this.updateState({ isAppActive: false });
  }

  onNetworkChange(isConnected: boolean): void {
    this.updateState({
      networkStatus: isConnected ? 'connected' : 'disconnected'
    });
  }
}
```

---

## ğŸ”§ Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹

### 1. Adapter Pattern (ĞĞ´Ğ°Ğ¿Ñ‚ĞµÑ€)

```typescript
// ĞĞ´Ğ°Ğ¿Ñ‚ĞµÑ€ Ğ´Ğ»Ñ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ñ Ñ€Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğ¼Ğ¸ Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¼Ğ¸ ÑĞµÑ€Ğ²Ğ¸ÑĞ°Ğ¼Ğ¸
export interface IAnalyticsProvider {
  trackEvent(event: string, parameters: object): Promise<void>;
  setUserProperty(key: string, value: string): Promise<void>;
  setUserId(userId: string): Promise<void>;
}

// Firebase Analytics Adapter
export class FirebaseAnalyticsAdapter implements IAnalyticsProvider {
  async trackEvent(event: string, parameters: object): Promise<void> {
    await analytics().logEvent(event, parameters);
  }

  async setUserProperty(key: string, value: string): Promise<void> {
    await analytics().setUserProperty(key, value);
  }

  async setUserId(userId: string): Promise<void> {
    await analytics().setUserId(userId);
  }
}

// Custom Analytics Adapter Ğ´Ğ»Ñ ÑĞ¾Ğ±ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ ÑĞµÑ€Ğ²ĞµÑ€Ğ°
export class CustomAnalyticsAdapter implements IAnalyticsProvider {
  constructor(private apiClient: ApiClient) {}

  async trackEvent(event: string, parameters: object): Promise<void> {
    await this.apiClient.post('/analytics/events', {
      event,
      parameters,
      timestamp: Date.now(),
      sessionId: await this.getSessionId()
    });
  }

  async setUserProperty(key: string, value: string): Promise<void> {
    await this.apiClient.post('/analytics/user-properties', {
      key,
      value,
      userId: await this.getUserId()
    });
  }

  async setUserId(userId: string): Promise<void> {
    await this.apiClient.post('/analytics/user-id', { userId });
  }

  private async getSessionId(): Promise<string> {
    // ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ID ÑĞµÑÑĞ¸Ğ¸
    return 'session-id';
  }

  private async getUserId(): Promise<string> {
    // ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ID Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    return 'user-id';
  }
}

// Unified Analytics Service
export class UnifiedAnalyticsService {
  private providers: IAnalyticsProvider[] = [];

  addProvider(provider: IAnalyticsProvider): void {
    this.providers.push(provider);
  }

  async trackGameEvent(event: GameAnalyticsEvent): Promise<void> {
    const promises = this.providers.map(provider =>
      provider.trackEvent(event.name, event.parameters)
    );

    await Promise.allSettled(promises);
  }

  async setUserProperty(key: string, value: string): Promise<void> {
    const promises = this.providers.map(provider =>
      provider.setUserProperty(key, value)
    );

    await Promise.allSettled(promises);
  }
}

// ĞĞ´Ğ°Ğ¿Ñ‚ĞµÑ€ Ğ´Ğ»Ñ Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¾Ğ² ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ¸Ğ³Ñ€
export interface IGameStorageFormat {
  serialize(game: GameEntity): string;
  deserialize(data: string): GameEntity;
  getVersion(): string;
}

export class JSONGameFormatAdapter implements IGameStorageFormat {
  getVersion(): string {
    return '1.0';
  }

  serialize(game: GameEntity): string {
    return JSON.stringify({
      id: game.id,
      difficulty: game.difficulty,
      originalGrid: game.originalGrid,
      currentGrid: game.currentGrid,
      startTime: game.startTime.toISOString(),
      playTime: game.getPlayTime(),
      hintsUsed: game.hintsUsed,
      errorsCount: game.errorsCount,
      version: this.getVersion()
    });
  }

  deserialize(data: string): GameEntity {
    const parsed = JSON.parse(data);

    return new GameEntity(
      parsed.id,
      parsed.originalGrid,
      parsed.currentGrid,
      parsed.difficulty,
      new SudokuRules(),
      {
        startTime: new Date(parsed.startTime),
        hintsUsed: parsed.hintsUsed,
        errorsCount: parsed.errorsCount
      }
    );
  }
}

export class CompressedGameFormatAdapter implements IGameStorageFormat {
  getVersion(): string {
    return '2.0';
  }

  serialize(game: GameEntity): string {
    // Ğ¡Ğ¶Ğ°Ñ‚Ğ¾Ğµ Ğ¿Ñ€ĞµĞ´ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¸Ğ³Ñ€Ñ‹
    const compressed = {
      i: game.id,
      d: game.difficulty.charAt(0), // e/m/h/x
      o: this.compressGrid(game.originalGrid),
      c: this.compressGrid(game.currentGrid),
      s: Math.floor(game.startTime.getTime() / 1000),
      p: game.getPlayTime(),
      h: game.hintsUsed,
      e: game.errorsCount,
      v: this.getVersion()
    };

    return JSON.stringify(compressed);
  }

  deserialize(data: string): GameEntity {
    const parsed = JSON.parse(data);

    const difficultyMap: { [key: string]: DifficultyLevel } = {
      e: 'easy', m: 'medium', h: 'hard', x: 'expert'
    };

    return new GameEntity(
      parsed.i,
      this.decompressGrid(parsed.o),
      this.decompressGrid(parsed.c),
      difficultyMap[parsed.d],
      new SudokuRules(),
      {
        startTime: new Date(parsed.s * 1000),
        hintsUsed: parsed.h,
        errorsCount: parsed.e
      }
    );
  }

  private compressGrid(grid: SudokuGrid): string {
    return grid.flat().join('');
  }

  private decompressGrid(compressed: string): SudokuGrid {
    const numbers = compressed.split('').map(Number);
    const grid: SudokuGrid = [];

    for (let i = 0; i < 9; i++) {
      grid[i] = numbers.slice(i * 9, (i + 1) * 9);
    }

    return grid;
  }
}
```

### 2. Facade Pattern (Ğ¤Ğ°ÑĞ°Ğ´)

```typescript
// Ğ¤Ğ°ÑĞ°Ğ´ Ğ´Ğ»Ñ Ğ¸Ğ³Ñ€Ğ¾Ğ²Ñ‹Ñ… Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹
export class GameFacade {
  private gameRepository: IGameRepository;
  private puzzleGenerator: IPuzzleGenerationStrategy;
  private commandManager: CommandManager;
  private eventBus: GameEventBus;
  private analyticsService: AnalyticsService;

  constructor(dependencies: GameDependencies) {
    this.gameRepository = dependencies.gameRepository;
    this.puzzleGenerator = dependencies.puzzleGenerator;
    this.commandManager = dependencies.commandManager;
    this.eventBus = dependencies.eventBus;
    this.analyticsService = dependencies.analyticsService;
  }

  // Ğ£Ğ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ğ¸Ğ³Ñ€Ñ‹
  async startNewGame(difficulty: DifficultyLevel): Promise<GameInfo> {
    try {
      // 1. Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ°Ğ·Ğ»
      const puzzle = await this.puzzleGenerator.generate(difficulty);

      // 2. Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ¸Ğ³Ñ€Ñƒ
      const factory = GameFactoryRegistry.createFactory({
        difficulty,
        gameMode: 'standard'
      });
      const game = factory.createGame(difficulty);
      game.setPuzzle(puzzle);

      // 3. Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼
      await this.gameRepository.save(game);

      // 4. ĞÑ‡Ğ¸Ñ‰Ğ°ĞµĞ¼ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´
      this.commandManager.clear();

      // 5. ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğµ
      await this.eventBus.publish({
        type: 'GAME_STARTED',
        timestamp: Date.now(),
        data: { gameId: game.id, difficulty }
      });

      // 6. Ğ¢Ñ€ĞµĞºĞ¸Ğ½Ğ³
      await this.analyticsService.trackEvent('game_started', {
        difficulty,
        gameId: game.id
      });

      return {
        id: game.id,
        difficulty: game.difficulty,
        grid: game.currentGrid,
        hintsRemaining: game.getHintsRemaining(),
        canUndo: false
      };

    } catch (error) {
      await this.analyticsService.trackEvent('game_start_error', {
        difficulty,
        error: error.message
      });
      throw error;
    }
  }

  // Ğ£Ğ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ´Ğ»Ñ Ñ…Ğ¾Ğ´Ğ°
  async makeMove(gameId: string, row: number, col: number, value: number): Promise<MoveResult> {
    try {
      const game = await this.gameRepository.findById(gameId);
      if (!game) throw new GameNotFoundError();

      const oldValue = game.currentGrid[row][col];

      // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ
      const command = new MakeMoveCommand(
        gameId, row, col, value, oldValue, this.gameRepository
      );

      // Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼ Ñ‡ĞµÑ€ĞµĞ· command manager
      await this.commandManager.executeCommand(command);

      // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½ÑƒÑ Ğ¸Ğ³Ñ€Ñƒ
      const updatedGame = await this.gameRepository.findById(gameId);
      const isComplete = updatedGame!.isComplete();

      // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ
      await this.eventBus.publish({
        type: 'MOVE_MADE',
        timestamp: Date.now(),
        data: { gameId, row, col, value, oldValue }
      });

      if (isComplete) {
        await this.eventBus.publish({
          type: 'GAME_COMPLETED',
          timestamp: Date.now(),
          data: { game: updatedGame }
        });
      }

      // ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ°
      await this.analyticsService.trackEvent('move_made', {
        gameId,
        isComplete,
        moveNumber: updatedGame!.getMoveCount()
      });

      return {
        success: true,
        isComplete,
        canUndo: this.commandManager.canUndo(),
        canRedo: this.commandManager.canRedo(),
        conflictCells: updatedGame!.getConflictCells()
      };

    } catch (error) {
      await this.analyticsService.trackEvent('move_error', {
        gameId,
        error: error.message
      });

      return {
        success: false,
        error: error.message,
        canUndo: this.commandManager.canUndo(),
        canRedo: this.commandManager.canRedo()
      };
    }
  }

  // Ğ£Ğ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹
  async undoMove(gameId: string): Promise<UndoResult> {
    if (!this.commandManager.canUndo()) {
      return { success: false, reason: 'Nothing to undo' };
    }

    try {
      await this.commandManager.undo();

      await this.eventBus.publish({
        type: 'MOVE_UNDONE',
        timestamp: Date.now(),
        data: { gameId }
      });

      await this.analyticsService.trackEvent('move_undone', { gameId });

      return {
        success: true,
        canUndo: this.commandManager.canUndo(),
        canRedo: this.commandManager.canRedo()
      };

    } catch (error) {
      return {
        success: false,
        reason: error.message
      };
    }
  }

  // Ğ£Ğ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´ÑĞºĞ°Ğ·ĞºĞ¸
  async useHint(gameId: string): Promise<HintResult> {
    try {
      const game = await this.gameRepository.findById(gameId);
      if (!game) throw new GameNotFoundError();

      if (game.getHintsRemaining() <= 0) {
        return { success: false, reason: 'No hints remaining' };
      }

      const command = new UseHintCommand(
        gameId,
        new HintService(),
        this.gameRepository
      );

      await this.commandManager.executeCommand(command);

      const hint = await new HintService().getBestHint(game.currentGrid);

      await this.eventBus.publish({
        type: 'HINT_USED',
        timestamp: Date.now(),
        data: { gameId, hint }
      });

      await this.analyticsService.trackEvent('hint_used', {
        gameId,
        hintsRemaining: game.getHintsRemaining() - 1
      });

      return {
        success: true,
        hint: hint!,
        hintsRemaining: game.getHintsRemaining() - 1,
        canUndo: this.commandManager.canUndo()
      };

    } catch (error) {
      return {
        success: false,
        reason: error.message
      };
    }
  }

  // ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ¸Ğ³Ñ€Ñ‹
  async getGameState(gameId: string): Promise<GameState> {
    const game = await this.gameRepository.findById(gameId);
    if (!game) throw new GameNotFoundError();

    return {
      id: game.id,
      difficulty: game.difficulty,
      grid: game.currentGrid,
      originalGrid: game.originalGrid,
      isComplete: game.isComplete(),
      playTime: game.getPlayTime(),
      hintsUsed: game.hintsUsed,
      hintsRemaining: game.getHintsRemaining(),
      errorsCount: game.errorsCount,
      canUndo: this.commandManager.canUndo(),
      canRedo: this.commandManager.canRedo(),
      conflictCells: game.getConflictCells()
    };
  }
}

// Ğ¤Ğ°ÑĞ°Ğ´ Ğ´Ğ»Ñ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞº Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
export class SettingsFacade {
  private settingsRepository: ISettingsRepository;
  private analyticsService: AnalyticsService;
  private configManager: GameConfigManager;

  constructor(dependencies: SettingsDependencies) {
    this.settingsRepository = dependencies.settingsRepository;
    this.analyticsService = dependencies.analyticsService;
    this.configManager = GameConfigManager.getInstance();
  }

  async updateTheme(theme: ThemeName): Promise<void> {
    await this.settingsRepository.updateSetting('theme', theme);
    this.configManager.updateConfig({ theme });

    await this.analyticsService.trackEvent('theme_changed', { theme });
  }

  async updateDifficulty(difficulty: DifficultyLevel): Promise<void> {
    await this.settingsRepository.updateSetting('defaultDifficulty', difficulty);
    this.configManager.updateConfig({ difficulty });

    await this.analyticsService.trackEvent('default_difficulty_changed', {
      difficulty
    });
  }

  async toggleSound(enabled: boolean): Promise<void> {
    await this.settingsRepository.updateSetting('soundEnabled', enabled);
    this.configManager.updateConfig({ soundEnabled: enabled });

    await this.analyticsService.trackEvent('sound_toggled', { enabled });
  }

  async getSettings(): Promise<AppSettings> {
    return await this.settingsRepository.getAll();
  }

  async resetToDefaults(): Promise<void> {
    await this.settingsRepository.resetToDefaults();

    const defaultConfig = {
      theme: 'light' as ThemeName,
      difficulty: 'medium' as DifficultyLevel,
      soundEnabled: true,
      vibrationsEnabled: true
    };

    this.configManager.updateConfig(defaultConfig);

    await this.analyticsService.trackEvent('settings_reset');
  }
}
```

### 3. Decorator Pattern (Ğ”ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€)

```typescript
// Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ´Ğ»Ñ Ğ¸Ğ³Ñ€Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ´Ğ²Ğ¸Ğ¶ĞºĞ°
export interface IGameEngine {
  makeMove(row: number, col: number, value: number): Promise<MoveResult>;
  validateMove(row: number, col: number, value: number): boolean;
  isComplete(): boolean;
}

// Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ°Ñ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
export class BasicGameEngine implements IGameEngine {
  constructor(
    private game: GameEntity,
    private rules: SudokuRules
  ) {}

  async makeMove(row: number, col: number, value: number): Promise<MoveResult> {
    const isValid = this.validateMove(row, col, value);

    if (isValid) {
      this.game.currentGrid[row][col] = value;
      return MoveResult.success(this.isComplete());
    }

    return MoveResult.invalid();
  }

  validateMove(row: number, col: number, value: number): boolean {
    return this.rules.isValidMove(this.game.currentGrid, row, col, value);
  }

  isComplete(): boolean {
    return this.rules.isComplete(this.game.currentGrid);
  }
}

// Ğ”ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
export class LoggingGameEngineDecorator implements IGameEngine {
  constructor(private engine: IGameEngine) {}

  async makeMove(row: number, col: number, value: number): Promise<MoveResult> {
    console.log(`Making move: (${row}, ${col}) = ${value}`);
    const startTime = Date.now();

    const result = await this.engine.makeMove(row, col, value);

    const endTime = Date.now();
    console.log(`Move completed in ${endTime - startTime}ms, result:`, result);

    return result;
  }

  validateMove(row: number, col: number, value: number): boolean {
    const isValid = this.engine.validateMove(row, col, value);
    console.log(`Validation: (${row}, ${col}) = ${value} -> ${isValid}`);
    return isValid;
  }

  isComplete(): boolean {
    const complete = this.engine.isComplete();
    console.log(`Game complete check: ${complete}`);
    return complete;
  }
}

// Ğ”ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ´Ğ»Ñ Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ¸
export class AnalyticsGameEngineDecorator implements IGameEngine {
  constructor(
    private engine: IGameEngine,
    private analytics: AnalyticsService
  ) {}

  async makeMove(row: number, col: number, value: number): Promise<MoveResult> {
    const result = await this.engine.makeMove(row, col, value);

    await this.analytics.trackEvent('game_move', {
      position: `${row},${col}`,
      value,
      success: result.success,
      gameComplete: result.isComplete
    });

    if (result.isComplete) {
      await this.analytics.trackEvent('game_completed', {
        completion_time: Date.now()
      });
    }

    return result;
  }

  validateMove(row: number, col: number, value: number): boolean {
    return this.engine.validateMove(row, col, value);
  }

  isComplete(): boolean {
    return this.engine.isComplete();
  }
}

// Ğ”ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ´Ğ»Ñ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸ Ñ Ğ¿Ğ¾Ğ´ÑĞºĞ°Ğ·ĞºĞ°Ğ¼Ğ¸
export class HintValidationDecorator implements IGameEngine {
  constructor(
    private engine: IGameEngine,
    private hintService: IHintService
  ) {}

  async makeMove(row: number, col: number, value: number): Promise<MoveResult> {
    const result = await this.engine.makeMove(row, col, value);

    if (!result.success) {
      // ĞŸÑ€ĞµĞ´Ğ»Ğ°Ğ³Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ´ÑĞºĞ°Ğ·ĞºÑƒ Ğ¿Ñ€Ğ¸ Ğ½ĞµĞ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ¼ Ñ…Ğ¾Ğ´Ğµ
      const hint = await this.hintService.getBestHint(
        this.getCurrentGrid()
      );

      if (hint) {
        result.suggestedHint = hint;
      }
    }

    return result;
  }

  validateMove(row: number, col: number, value: number): boolean {
    return this.engine.validateMove(row, col, value);
  }

  isComplete(): boolean {
    return this.engine.isComplete();
  }

  private getCurrentGrid(): SudokuGrid {
    // ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ ÑĞµÑ‚ĞºĞ¸
    return []; // placeholder
  }
}

// Ğ”ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ´Ğ»Ñ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ñ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸
export class TimeLimitDecorator implements IGameEngine {
  private startTime: number;
  private timeLimit: number;

  constructor(
    private engine: IGameEngine,
    timeLimitSeconds: number
  ) {
    this.startTime = Date.now();
    this.timeLimit = timeLimitSeconds * 1000;
  }

  async makeMove(row: number, col: number, value: number): Promise<MoveResult> {
    if (this.isTimeExpired()) {
      return MoveResult.timeExpired();
    }

    return await this.engine.makeMove(row, col, value);
  }

  validateMove(row: number, col: number, value: number): boolean {
    if (this.isTimeExpired()) {
      return false;
    }

    return this.engine.validateMove(row, col, value);
  }

  isComplete(): boolean {
    return this.engine.isComplete();
  }

  private isTimeExpired(): boolean {
    return (Date.now() - this.startTime) > this.timeLimit;
  }

  getRemainingTime(): number {
    const elapsed = Date.now() - this.startTime;
    return Math.max(0, this.timeLimit - elapsed);
  }
}

// Ğ¤Ğ°Ğ±Ñ€Ğ¸ĞºĞ° Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ´ĞµĞºĞ¾Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ´Ğ²Ğ¸Ğ¶ĞºĞ¾Ğ²
export class GameEngineFactory {
  static createEngine(
    game: GameEntity,
    options: GameEngineOptions
  ): IGameEngine {
    let engine: IGameEngine = new BasicGameEngine(game, new SudokuRules());

    // ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ´ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹ Ğ² Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¾Ñ‚ Ğ¾Ğ¿Ñ†Ğ¸Ğ¹
    if (options.enableLogging) {
      engine = new LoggingGameEngineDecorator(engine);
    }

    if (options.enableAnalytics) {
      engine = new AnalyticsGameEngineDecorator(
        engine,
        AnalyticsService.getInstance()
      );
    }

    if (options.enableHints) {
      engine = new HintValidationDecorator(
        engine,
        new HintService()
      );
    }

    if (options.timeLimit) {
      engine = new TimeLimitDecorator(engine, options.timeLimit);
    }

    return engine;
  }
}
```

---

## âœ… ĞšÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸Ğ¸ Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ğ¾Ğ²

**ĞŸĞ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ ÑÑ‡Ğ¸Ñ‚Ğ°ÑÑ‚ÑÑ Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ñ‹Ğ¼Ğ¸, ĞºĞ¾Ğ³Ğ´Ğ°:**

1. âœ… **ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹** - Clean Architecture, Repository, DI
2. âœ… **ĞŸĞ¾Ğ²ĞµĞ´ĞµĞ½Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹** - Observer, Command, Strategy
3. âœ… **ĞšÑ€ĞµĞ°Ñ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹** - Factory, Builder, Singleton
4. âœ… **Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹** - Adapter, Facade, Decorator
5. âœ… **TypeScript Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸** - Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ñ‹ ĞºĞ¾Ğ´Ğ°
6. âœ… **Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ React Native** - Ğ°Ğ´Ğ°Ğ¿Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾Ğ´ Ğ¼Ğ¾Ğ±Ğ¸Ğ»ÑŒĞ½ÑƒÑ Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ñƒ
7. âœ… **Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼Ğ¾ÑÑ‚ÑŒ** - Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹ ÑƒĞ¿Ñ€Ğ¾Ñ‰Ğ°ÑÑ‚ unit testing
8. âœ… **ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ** - Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ¼Ğ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ñ‹Ñ… ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²

### ĞŸĞ¾ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ğ°Ğ¼Ğ¸

- **ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ½Ñ‹Ğµ**: 3/3 (Clean Architecture, Repository, DI)
- **ĞŸĞ¾Ğ²ĞµĞ´ĞµĞ½Ñ‡ĞµÑĞºĞ¸Ğµ**: 3/3 (Observer, Command, Strategy)
- **ĞšÑ€ĞµĞ°Ñ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğµ**: 3/3 (Factory, Builder, Singleton)
- **Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ½Ñ‹Ğµ**: 3/3 (Adapter, Facade, Decorator)
- **Ğ¡Ğ¿ĞµÑ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ**: Event Bus, Command Manager, Game Engine

---

## ğŸš€ Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğµ ÑˆĞ°Ğ³Ğ¸

ĞŸĞ¾ÑĞ»Ğµ ÑƒÑ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ğ¾Ğ² Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ:

1. **3.1.1** - ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ° Ğ¸ ÑÑ€ĞµĞ´Ñ‹ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸
2. **3.1.2** - Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ±Ğ°Ğ·Ğ¾Ğ²Ğ¾Ğ¹ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°
3. **3.2.1** - Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğ° Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ ÑÑƒĞ´Ğ¾ĞºÑƒ
4. **3.2.2** - Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ğ° Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ ÑÑƒĞ´Ğ¾ĞºÑƒ
5. **3.3.1** - Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ñ… ÑĞºÑ€Ğ°Ğ½Ğ¾Ğ² Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ

---

**ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½ĞµĞµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ**: 19 ÑĞµĞ½Ñ‚ÑĞ±Ñ€Ñ 2025
**Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ**: âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾